#### 2020牛客暑假多校训练营第七场总结
##### 题目解析
###### D题解题思路
题目大意：给出几个数。对于每一个数n进行一个判断，求1~n的平方和是不是一个平方数。是则输出一行Fake news!，不是则输出Nobody knows it better than me!
平方和公式：1^2 + 2^2 + 3^2 +……+ n^2=n(n+1)(2n+1)/6；但根据相关推理，符合平方和为平方数的仅有1和24，所以这题为答案为特例。
```C++
#include<stdio.h>
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
   {
        int n;
        scanf("%d", &n);
        if(n==1||n==24)   printf("Fake news!\n");
        else    printf("Nobody knows it better than me!\n");
    }
    return 0;
}

```
###### B题解题思路
题目大意：有n个重症医院，m个轻症医院，n*m个口罩，分成k份（每份均不可分开），使得若发给n个医院，每个医院可以刚好分到m个；若发给m个医院，每个医院可以刚好分到n个，求最小的k，以及这k个数的字典序最大的排列 。
运用迭代的思想，首先为了使得箱子数最少，每个箱子就应该尽可能的多装。每次优先装min(n,m)个箱子，每个箱子装min(n,m)。装了这些之后，就还剩下(max(m,n)-min(n,m))*min(n,m)个，对于剩下的这些口罩我们可以继续重复上述操作来装箱子。
```C++
#include<bits/stdc++.h>
using namespace std;

long long gcd(long long m, long long n) {
	return m % n == 0 ? n : gcd(n, m % n);
}
const int maxn = 1e4;
typedef long long ll;
ll dp[maxn][maxn];



int main() {

	int t;
	scanf("%d", &t);
	while (t--) {
		int m, n;
	
		scanf("%d%d", &n, &m);

		int i;
		vector<int> ans;

		int cnt = 0;
		int tmp = 0;
		int lcm;
		while (n>0&&m>0) {
			if (n > m)
				swap(n, m);
			for (i = 0; i < n; i++) {
				ans.push_back(n);
			}
			m -= n;
		}
		printf("%d\n", ans.size());
		for (i = 0; i < ans.size(); i++) {
			if (i)printf(" ");
			printf("%d",ans[i]);
		}
		printf("\n");

		
	}

	return 0;

}


```
###### H题解题思路
题意可以等价为求(x,y)满足1≤x≤n,1≤y≤n，且x mod y=0或者x mod y=1.
1.对于x=1或者y=1的情况单独考虑，结果为n+k-1;
2.对于x≥2和y≥2，模数为0的时候，此时其实就是寻找对于[2,k]中每个数为其倍数，在前n个数中存在多少个数为其倍数。而这个过程可以用除法分块解决。对于x，寻找前n个数中有多少个数为其倍数等价为n/x。除法分块是寻找对于n/i，存在多少个ii满足这个式子的值相同。模数为1时将n变成n-1即可。
```C++
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

const int mod = 1e9 + 7;
const int maxn = 5000 + 7;

ll get1(ll n,ll k) {
    ll ans = n;
    ll r = 2,l = 2;
    for(;l <= k;l = r + 1) {
        if(n / l == 0) r = k;
        else r = min(k,n / (n / l));
        ans += n / l % mod * ((r - l + 1) % mod);
        ans %= mod;
    }
    return ans;
}

ll get2(ll n,ll k) {
    ll ans = k - 1;
    ll r = 2,l = 2;
    for(;l <= k;l = r + 1) {
        if(n / l == 0) r = k;
        else r = min(k,n / (n / l));
        ans += n / l % mod * ((r - l + 1) % mod);
        ans %= mod;
    }
    return ans;
}

int main() {
    ll n,k;scanf("%lld%lld",&n,&k);
    ll ans = get1(n,k) + get2(n - 1,k);
    printf("%lld\n",ans % mod);
    return 0;
}


```
