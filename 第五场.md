### [D. Drop Voicing](https://ac.nowcoder.com/acm/contest/5670/D)


### **题意**  
有两个操作：将位置倒数第二的数字放到第一位置中，将最小的位置挪到最大的位置。
给定一个数列，问它经过多少次第一个操作的集合才能将数列从小到大排序。

### **思路**  
题目给出的操作等价于把一个数字往前扔任意位，统计+1
例：6,2,4,5,1,3->1,6,2,4,5,3->...->4,5,1,6,2,3 ：3前移了三位
求循环串的最大上升子序列，串的长度减去LIS的长度即为答案。

### **代码** 
```
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <set>
#include <cstdlib>
#include <cstdbool>

using namespace std;
typedef long long ll;
const int N = 1000;
int a[N + 10], d[N + 10];
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
	}
	for (int i = 1; i <= n; i++)
	{
		a[i + n] = a[i];
	}
	int maxn = 0;
	for (int i = 1; i <= n; i++)
	{
		int cnt = 0, p = 1;
		d[1] = a[i];
		while (++cnt < n)
		{
			int temp = i + cnt;
			if (d[p] <= a[temp])
			{
				d[++p] = a[temp];
			}
			else
			{
				int x = lower_bound(d + 1, d + p + 1, a[temp]) - d;
				d[x] = a[temp];
			}
		}
		maxn = max(maxn, p);
	}
	printf("%d\n", n - maxn);
	return 0;
}
``` 

### [E.  Bogo Sort](https://ac.nowcoder.com/acm/contest/5670/E)


### **题意**  
问有多上1~n的数列可以满足用给定数列p进行不断排序最终可以得到从小到大的序列

### **思路**  
查找p中有几个“轮换的序列”（我不知道它的学名是啥hhh），每个序列的个数相乘在除上它们的最小公因数为所得

关于“轮换的序列”：
1，2，3，4，5：“轮换的序列”为（1）（2）（3）（4）（5）
2，3，4，5，6，1：“轮换的序列”为（1，2，3，4，5，6）

为什么要除上最小公因数：
2，3，4，1，6，7，8，9，10，5：“轮换的序列”为（1，2，3，4），（5，6，7，8，9，10）
用一次p的序列：2，3，4，1，6，7，8，9，10，5
用两次p的序列：3，4，1，2，7，8，9，10，5，6
用三次p的序列：4，1，2，3，8，9，10，5，6，7
……
可以感觉到当数列回归1，2，3，4，5，6，7，8，9，10时其次数为最大次数，该次数也等于不同序列的个数，即为所求，正为4*6/gcd(4,6)

p.s.当数很大时，可以考虑用python

### **代码** 
```
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)
    
if __name__ == '__main__':
    n = int(input())
    v = []
    arr = [0]
    arr1 = list(map(int, input().strip().split()))
    #for i in range (0, n, 1):
    arr.extend(arr1)
    num = 0
    #print(arr)
    for j in range (1, n+1, 1):
        if arr[j] == j:
            continue
        elif arr[j] == 0:
            continue
        else:
            while arr[j] != 0:
                temp=j
                num+=1
                j = arr[j]
                arr[temp]=0
            v.append(num)
            num=0
    sum = 1
    for i in v:
        sum = sum * i // gcd(sum, i)
    sum = sum % (10**n)
    print(sum)
            

```

### [F.  	DPS ](https://ac.nowcoder.com/acm/contest/5670/F)


### **题意**  

签到题，给定$d_i$， 空格长度为$s_i$，对敌人造成最大伤害的玩家用*来代替最后一个空格

### **思路**  

模拟即可
但是千万要**仔细审题**，输出*的条件是$d_i$最大而不是$s_i$最大

### **代码**
```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cmath>
#include<math.h>
#include <iostream>
using namespace std;
#pragma warning(disable:4996)
typedef long long ll;
ll a[105];
int s[105];
int main()
{
    int n;
    ll max = -1;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%lld", &a[i]);
        if (max < a[i])
            max = a[i];
    }
    for (int i = 0; i < n; i++) {
         
        s[i] = ceil((50 * (double)a[i] / max));
    }
     
    for(int j=0;j<n;j++) {
         
        printf("+");
        for (int i = 0; i < s[j]; i++)
            printf("-");
        printf("+\n");
        printf("|");
        for (int i = 0; i < s[j]-1; i++)
            printf(" ");
        if (a[j] == max)printf("*");
        else if(s[j] == 0);
        else printf(" ");
     
        printf("|%lld\n",a[j]);
        printf("+");
        for (int i = 0; i < s[j]; i++)
            printf("-");
        printf("+\n");
    }
    return 0;
}
```

### [I.   Hard Math Problem ](https://ac.nowcoder.com/acm/contest/5670/I)


### **题意**  

有一个N×M的网格中，可放置H、E、G，一个H周围至少挨着一个E和一个G，当N和M趋于无穷大时，H的最大值

### **思路**  

思维题

忽视了无穷大的力量QAQ，之前的想法是1/2,~~甚至分N×M的结果是奇数还是偶数考虑~~，一直在做定量分析

EHEHE

HGHGH

EHEHE

HGHGH

正确思路为由于N,M是无穷大的，则每个H都符合临近一个E和G，一个交错的E,G斜排可以对应上下两个H斜排，如下图

HGHH

EHHG

HHEH

HGHH

EHHG

HHEH

16/24=2/3

### **代码**
```
#include <iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
    cout<<0.666667<<endl;
}

```