# 题解
时间：8.12
主要总结一下c题
[题目链接](https://codeforces.com/contest/1395/problem/C)

## 思路分析
&ensp;&ensp;$ans$的数据范围不是很大，从小到大枚举答案$ans$，并且对于每一个$a_i$，一定可以找到一个$b_j$使得$$(a_i\&b_j)|ans=ans$$成立，那么就可以从小到大枚举ans了（看到数据范围小应该想到枚举的）。
代码
```cpp
#include <ctime>
#include <cstdlib>
#include<iostream>
#include<algorithm>
#include<math.h>
#include<cstdio>
#include<string>
#include<string.h>
#include<list>
#include<queue>
#include<sstream>
#include<vector>
#include <cassert>   // assert
#include<set>
#include<map>
#include<deque>
#include<stack>
using namespace std;
#define debug(x) cout<<"###"<<x<<"###"<<endl;
const int INF=0x3f3f3f3f,mod=1e9,Maxn=1e3;
const double eps=1e-8;
typedef long long ll;
int a[Maxn];
int b[Maxn];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<m;i++)cin>>b[i];
    for(int ans=0;ans<(1<<9);ans++){
        bool ff=0;
        for(int i=0;i<n;i++){
            bool f=0;
            for(int j=0;j<m;j++){
                if(((a[i]&b[j])|ans)==ans){//ans可能是
                    f=1;
                    break;
                }
            }
            if(f==0){//ans不符合找下一个 
                ff=1;
                break;
            }
        }
        if(ff==0){
            printf("%d\n",ans);
            break;
        }
    }
    return 0;
}

```
