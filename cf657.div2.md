# cf657



https://codeforces.com/contest/1379

A

给一个字符串，里面存在问号的地方可以换成任意字母，问能否令其中只存在一次指定子串。

暴力枚举，自己写的时候逻辑没想通wa了好久。。

```
#include<bits/stdc++.h>
using namespace std;
const string T="abacaba";
string s;
int n;
bool check(string &a){
	int cnt=0;
	for(int i=0;i+7<=n;i++)
		if(a.substr(i,7)==T) cnt++;
	return cnt==1;
}
int main(){

	int t;
	cin>>t;
	while(t--)
	{
		cin>>n>>s;
		int f=0;
		for(int i=0;i+7<=n;i++)
		{
			string ss=s;
			bool ok=1;
			for(int j=0;j<7;j++)
			{
				if(ss[i+j]!=T[j]&&ss[i+j]!='?')
				{
					ok=0;
					break;
				}
				ss[i+j]=T[j];	
			}
			if(ok&&check(ss))
			{
				for(int j=0;j<n;j++)
				{
					if(ss[j]=='?') ss[j]='h';
				}
				cout<<"Yes\n";
				f=1;
				cout<<ss<<endl;
				break;
			}
		}
		if(!f) cout<<"No\n";
	}
	return 0;
}
```

B

给l，r，m，求是否存在l<= a,b,c <= r，满足n*a+b-c = m，得到n = （m+c-b）/a。

c-b= k*a - m%a，由于abc同属一个范围，m%a<=a，-a<=c-b<=a，知k只可能是0或者1.

又因为c-b 在{l-r,r-l}内，枚举a判断这几个条件即可

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll m,l,r,a,b,c;
int main() 
{
	int T; cin>>T;
	while(T--) 
	{
		
		scanf("%lld%lld%lld",&l,&r,&m);
		ll mx=r-l,mi=l-r;
		for(a=l;a<=r;a++) 
		{
			if(a-m%a<=mx) 
			{
				b=l;c=l+a-m%a;break;
			} 
			else if((-m%a)>=mi) 
			{
				b=r;c=r-m%a; break;
			}
		}
		printf("%lld %lld %lld\n",a,b,c);
	}
	
	
	return 0;
}
```

C

有m种花，每种花第一次取能得到ai，再取每次得到bi，要取n束花，求最大权值

枚举每个ai，先拿ai，再拿全部大于ai的bi，最后再用bi补上

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int mxn = 1e5 + 5;
ll a[mxn],b[mxn],c[mxn],sum[mxn];
int n,m;

bool cmp(ll x,ll y){return x>y;}

int find(int x)//找排序后第一个小于所选bi的ai下标 
{
	int l=0,r=m-1,ans=m;
	while(l<=r)
	{
	    int mid=(l+r)>>1;
	    if(c[mid]<=x) r=mid-1,ans=mid;
	    else l=mid+1;
	}
	return ans-1;
}

int main()
{
    int T;cin>>T;
    while(T--)
	{
        cin>>n>>m;
        for(int i=0;i<m;i++)
		{
           scanf("%lld%lld",a+i,b+i);
           c[i]=a[i];
        }
        sort(c,c+m,cmp);
        sum[0]=c[0];
        for(int i=1;i<m;i++)sum[i]=sum[i-1]+c[i];
        ll ans=0,anss=0;
        for(int i=0;i<m;i++)
		{
            int j=find(b[i]);
            if(a[i]>=b[i]) anss=sum[min(j,n-1)]+b[i]*max((n-j-1),0);
            else anss=sum[min(j,n-2)]+a[i]+b[i]*max((n-j-2),0);
            ans=max(ans,anss);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```
