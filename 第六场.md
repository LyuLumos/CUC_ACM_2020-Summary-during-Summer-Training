### [B. Binary Vector](https://ac.nowcoder.com/acm/contest/5671/B)


### **题意**  
抱歉，题意我依旧理解无能，感觉什么线性的知识那边有欠缺（？）
总之从答案中找规律，1/2-(3/4)->3/8-(7/8)->21/64-(...)->...

### **思路**  
运用费马小定理，2的逆元为500000004，之后乘的数可化为1-(1/2)^n，即得1-500000004^n

### **代码** 
```
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <set>
#include <cstdlib>
#include <cstdbool>
#include <map>
using namespace std;
typedef long long ll;
ll mod = 1000000007;
ll inv = 500000004;
ll arr[20000005];

int main()
{
	arr[1] = inv;
	ll tem = inv;
	for (int i = 2; i <= 20000000; i++)
	{
		tem = tem * inv % mod;
		arr[i] = arr[i - 1] * (1 + mod - tem) % mod;
		//if (i == 3)
			//printf("%lld\n", arr[i]);
	}
	for (int i = 2; i <= 20000000; i++)
	{
		arr[i] = arr[i-1]^arr[i];
	}
	int t;
	scanf("%d", &t);
	
	while (t--)
	{
		int n;
		scanf("%d", &n);
		printf("%lld\n", arr[n]);
	}
}
```
 

### [C.  Combination of Physics and Maths](https://ac.nowcoder.com/acm/contest/5671/C)


### **题意**  
压强定义：一个矩阵的所有数之和/最后一行数之和

在n*m矩阵中，求压强最大的可非连续子矩阵
### **思路**  
求出单列的最大压强即为最终结果

### **代码** 
```
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <set>
#include <cstdlib>
#include <cstdbool>
using namespace std;
typedef long long ll;
int num[205][205];
int sum[205];
int main()
{
    int t;
    scanf("%d", &t);
    while (t--)
    {
        int n, m;
        double maxn = 1.0;
        scanf("%d %d", &n, &m);
        memset(sum, 0, sizeof(sum));
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                scanf("%d", &num[i][j]);
            }
        }
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                sum[j] += num[i][j];   
                 
                if (i == 1)
                    continue;
                double temp = 1.0 * sum[j] / (1.0 * num[i][j]);
                 
                if (temp > maxn)
                    maxn = temp;
            }
        }
        printf("%.8lf\n", maxn);
    }
}    

```

### [E. Easy Construction](https://ac.nowcoder.com/acm/contest/5671/E)


### **题意**  


给定n,k，求一个关于n的排列，使得对1-n中的每个i，P都存在长度为i的子序列，每个子序列的和模n都余k。（有解输出P，无解输出-1）
### **思路**  
构造题

如果1-n的总和模n余k,则此时一定有解。

当n为奇数时，余数为0，令P={1,n-1,2,n-2,...,(n-1)/2,(n+1)/2,n}

当n为偶数时，余数为n/2，令P={1,n-1,2,n-2,...,n/2-1,n/2+1,n/2,n}



### **代码**
```
#include <iostream>
#include <algorithm>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <set>
#include <cstdlib>
#include <cstdbool>
using namespace std;
typedef long long ll;
int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
     
    if (k >= n)
    {
        printf("-1\n");
        return 0;
    }
    int sum = (1 + n) * n / 2;
    if (sum % n != k)
    {
        printf("-1\n");
        return 0;
    }
    if (n % 2 == 1)
    {
        for (int i = 1; i <= (n - 1) / 2; i++)
        {
            printf("%d %d ", i, n - i);
        }
        printf("%d\n", n);
        return 0;
    }
    else
    {
        int mod = n / 2;
        for (int i = 1; i < mod; i++)
        {
            printf("%d %d ", i, n - i);
        }
        printf("%d %d\n", mod, n);
        return 0;
    }
}
```

### [G.   Grid Coloring ](https://ac.nowcoder.com/acm/contest/5671/G)


### **题意**  

给n*n的网格图的边染k种色，每种色染的边数相同，构造不存在同色环及整行整列不同色（即一行或一列至少存在两种颜色）的方案

### **思路**  

- 当n=1, k=1或者2n(n+1)不是k的倍数时，无解
- 保证同行、同列没有两条相邻的边
- 相邻两行同一列、相邻两列同一行的边颜色不相等

构造：当k不整除n的时候，按1,2,3...k的顺序分配权值；当k整除n的时候，在偶数行/列上循环移1位即可
### **代码**
```
#include<cstdio>
#include<iostream>
using namespace std;
#pragma warning(disable:4996)

int main()
{
    int t,x,n,k;
   scanf("%d",&t);
   
   while (t--) {
       scanf("%d%d", &n,&k);
       if (n == 1 || k == 1 || 2 * n * (n + 1) % k) {
           cout << "-1" << endl;
           continue;
      }
       int t = 0;
       if (n % k == 0) {
           for (int i = 1; i <= 2 * (n + 1); i++) {
               for (int j = 1; j <= n; j++) {
                   t = t % k + 1;
                   printf("%d ", t);
               }
               printf("\n");
               t = t % k + 1;
           }
       }
       else {
           for (int i = 1; i <= 2 * (n + 1); i++) {
               for (int j = 1; j <= n; j++) {
                   t = t % k + 1;
                   printf("%d ", t);
               }
               printf("\n");
           }
       }

   }
   return 0;
  
}
```