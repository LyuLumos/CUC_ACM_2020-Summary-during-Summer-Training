# 2020牛客第六场笔记
## 题目解析
*E题解题思路*
因为要求1到n所有数都排列上，所以有解的条件是（1+n)*n/2 % n = k。
然后根据n的奇偶性讨论。当n为偶数时排列为{n,k,n-1,1,n-2,2…}，当n为奇数时k=0，排列为{n, n-1,1,n-2,2…}
```c++
#include<bits/stdc++.h>
using namespace std;
int v[5005];
int a[5005];
int main()
{
    memset(v, 0, sizeof(v));
    int n, k, flag = 1, cnt = 0;
    cin>>n>>k;
    int s = n - 1;
    int t = 1;
    if((1+n) * n / 2 % n != k) flag = 0;
    else if(k == 0){
        if(n % 2 == 0){
            flag = 0;
        }
        a[cnt++] = n;;
        while(t < s) {
            a[cnt++] = s--;
            a[cnt++] = t++;
        }
    }
    else{
        if(n % 2 == 1){
            flag = 0;
        }
        a[cnt++] = n;
        a[cnt++] = k;
        while(t < s) {
            a[cnt++] = s--;
            a[cnt++] = t++;
        }
    }
    if(flag){
        for(int i = 0; i < n; i++){
            cout<<a[i]<<" ";
        }
    }
    else cout<<-1<<endl;
}
```
*C题解题思路*
题目要求找到压强最大的子矩阵。单列的值才可最大，即枚举每一个元素找它的压强值，这里可以用一个前缀和把它们存入一个数组然后进行比较找出最大值即可。
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int a[202][202];
int sum[202][202];
int main()
{
    int t;
    scanf("%d",&t);
	while(t--){
        double x =1;
		int n , m, cnt = 0, flag = 0;
		scanf("%d%d",&n,&m);
		for(int i = 1; i <=n; i++){
			for(int j = 1; j <=m; j++){
				scanf("%d",&a[i][j]);
			}
		}
		for(int i=0;i<=max(n,m);++i) sum[i][0] = sum[0][i] = 0;
		for(int j=1;j<=m;++j)
        {
            for(int i=1;i<=n;++i)
            {
                sum[i][j] = sum[i-1][j] + a[i][j];
            }
        }
		for(int j = 1; j <=m; j++){
			for(int i = 1; i<=n;++i)
            {
                double y = (double)sum[i][j]/a[i][j];
                x = max(x,y);
            }
		}
		printf("%.8f\n",x);
	}
}
```
*总结*
做题的时候需要仔细审题，弄清题意，在提交自己的代码之前要多尝试几组数据验证一下，不能盲目提交，这次的c题wa了9次就有不少罚时。