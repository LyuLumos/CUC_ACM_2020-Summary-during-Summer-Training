## [B. Binary Vector](https://ac.nowcoder.com/acm/contest/5671/B)
### 题意
随机n个n维01向量线性无关的概率
### 解题
$f_{n-1}\cdot \frac{ (2^n-1)}{(2^n)}=f_n$
```cpp
#include<bits/stdc++.h>
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
#define show(x) std::cerr << #x << "=" << x << std::endl
using namespace std;
typedef long long ll;
const double eps=1e-8;
const int maxn = 2e7+5;
const int mod = 1e9+7;
const int inf = 0x3f3f3f3f;
int t;
int n,m;
ll qpow(ll a,ll b){ll ans=1;for(;b;b>>=1){if(b&1) ans=ans*a%mod; a=a*a%mod;} return ans;}
ll f[maxn],ans[maxn],p[2*maxn];
inline ll sub(ll a,ll b)
{
    a-=b;
    return a<0?a+mod:a;
}
inline ll add(ll a,ll b)
{
    a+=b;return a>=mod?a-mod:a;
}
void init()
{
    ans[1] = f[1] = 5e8+4;
    ll p = 2;
    ll y = ans[1]*ans[1]%mod;
    ll x = ans[1];
    for(int i=2;i<=20000000;++i)
    {
        p = p*2%mod;
        x = x*f[1]%mod;
        f[i] = (f[i-1]-f[i-1]*x)%mod+mod;
        ans[i] = ans[i-1]^f[i];
    }
}
int main()
{
    init();
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        printf("%lld\n",ans[n]);
    }
    return 0;
}
```
## [C. Combination of Physics and Maths](https://ac.nowcoder.com/acm/contest/5671/C)
### 题意
给你一个n*m的矩阵，求矩阵的子矩阵最大压强为多少（压力F为子矩阵所有元素之和，受力面积为子矩阵最后一行的元素之和）
```cpp
#include<bits/stdc++.h>
#define pb push_back
#define pii pair<int,int>
#define fi first
#define se second
#define show(x) std::cerr << #x << "=" << x << std::endl
using namespace std;
typedef long long ll;
const double eps=1e-8;
const int maxn = 2e5+5;
const int mod = 1e9+7;
const int inf = 0x3f3f3f3f;
int t;
int n,m;
ll a[205][205];
ll f[205][205];
void init()
{
    for(int i=1;i<=n;++i) f[i][0] = 0;
    for(int i=1;i<=m;++i) f[0][i] = 0;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            f[i][j] = f[i][j-1] + a[i][j];
        }
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            f[i][j]+= f[i-1][j];
        }
    }
}
ll get(int x1,int y1,int x2,int y2)
{
    return f[x2][y2] - f[x1-1][y2] - f[x2][y1-1] + f[x1-1][y1-1];
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        double ans = 1;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=m;++j)
            {
                scanf("%lld",&a[i][j]);
            }
        }
        ll F,S;
        init();
        for(int j=1;j<=m;++j)
        {
            for(int i=1;i<=n;++i)
            {
                ll k1 = get(1,j,i,j);
                ll k2 = a[i][j];
                double tmp = (double)k1/k2;
                if(tmp>ans)
                {
                    ans = tmp;
                    F = k1,S = k2;
                }
            }
        }
        printf("%.8f\n",ans);
        //printf("%lld %lld\n",F,S);
    }
    return 0;
}
```
## [E. Easy Construction](https://ac.nowcoder.com/acm/contest/5671/E)
### 题意
给定n,k，构造一个1-n的排列P，使得对于1-n中的每个i，P都存在一个长为i的子序列，而每个子序列之和模n都余k。有解则输出任意P，无解输出-1。
### 解题思路
当i=n时，sum必定等于$\frac{n(n+1)}{2}\mod k=\frac{n}{2}$，那么p就可以构造为$n, [n/2(若n为偶数), ]1,n-1,2,n-2......$
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
vector<int> a;
int main() {
	int n, k;
	scanf("%d%d",&n,&k);
	if(n==1) {
		puts("1"); return 0;
	} else if((n*(n+1)/2)%n==k){
		a.push_back(n);
		if(n%2==0) {
			a.push_back(n/2);
			for(int i=1;i<n/2;i++)
				a.push_back(i),
				a.push_back(n-i);
		}
		else {
			for(int i=1;i<=n/2;i++)
				a.push_back(i),
				a.push_back(n-i);
		}
		for(int i=0;i<n;i++) printf("%d ",a[i]);
	}
	else puts("-1");
}
```