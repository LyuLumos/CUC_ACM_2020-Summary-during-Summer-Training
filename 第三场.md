<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });
</script>


### [A. Clam and Fish](https://ac.nowcoder.com/acm/contest/5668/A)


### **题意**  

给定N种状态，每种状态对应不同数量的鱼和蛤蜊（鱼饵），再给定四种动作  
1.有鱼，直接钓鱼  
2.有蛤蜊，用蛤蜊做鱼饵   
3.有鱼饵，即使没有鱼也可以钓鱼上来    
4.什么也做不了  
每回四个动作里就只能选一个，问怎么安排最后钓上来的鱼最多。  

### **思路**  

开始的想法比较简单，就是有鱼/有鱼饵就钓鱼，没法钓鱼就用蛤蜊做鱼饵或者什么也不做，出现了一个问题就是这种思路在给定状态为1100的时候只能钓上来一条鱼，但最佳情况是两条。关键在于状态1是做鱼饵还是钓鱼。
思路是尽量把1与0配对，一个做鱼饵，一个钓鱼，多出来的1就自产自用。  

### **代码**  
```  
#include<iostream> 
#include<cstring>
using namespace std;
const int maxn=2e6+5;
int main()
{
    int fish, bait,sum;
    int n,t;
    cin>>t;
    while(t--)
    {
        char s[maxn];
        fish=0;
        bait=0;
        sum=0;
        int flag=0;
        cin>>n;
        cin>>s;
        for(int i=0;i<n;i++)
        {
            if(s[i]=='0')
            {
                if(flag>=1)
                {
                    flag--;
                    sum++;
                }
            }
            if(s[i]=='1')
            {
                flag++;
            }
            if(s[i]=='2')fish++;
            if(s[i]=='3')
            {
                fish++;
            }
        }
        fish+=sum;
        fish+=flag/2;
        cout<<fish<<"\n";
    }
    return 0;
}  
```  


### [B. Classical String Problem](https://ac.nowcoder.com/acm/contest/5668/B)


### **题意**  

对字符串S进行两种操作：`A,X`表示输出第X个字符；`M,X`表示当X为正/负时将前M/后M个字符移到后/前面

### **思路**
将字符串看成首位相连的环，每次计算下标取余即可

~~真的移动字符串会超时~~

### **代码**
```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <iostream>
using namespace std;
char s[2000005];
 
int main()
{
    scanf("%s", s);
    int lens = strlen(s);
    int beg = 0;
    int n;
    scanf("%d\n", &n);
    while (n--)
    {
        char k; int x;
        scanf("%c %d\n", &k, &x);
         
        //      printf("%c\n", k);
        if (k == 'A')
        {
            int temp = (beg + x - 1) % lens;
            printf("%c\n", s[temp]);
        }
        else
        {
            if (x > 0)
            {
                beg = (beg + x) % lens;
            }
            else
            {
                beg = (beg + lens + x) % lens;
            }
        }
    }
}
```


### [C. Operation Love](https://ac.nowcoder.com/acm/contest/5668/C)

### **题意**

手掌形状固定已知，左右手对称，给定20个坐标判断是左手还是右手。

### **思路** 

枚举所有坐标的距离，找到一个点有两个点与它一个距离9.0一个距离6.0，然后这三个点的坐标进行讨论

### **代码**
```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
struct hh
{
	double x, y;
}h[25];
int main()
{
	int t;
	hh pa, p6, p10;
	scanf("%d", &t);
	while (t--)
	{
		for (int i = 0; i < 20; i++)
		{
			scanf("%lf %lf", &h[i].x, &h[i].y);
			//	printf("!!%lf %lf\n", h[i].x, h[i].y);
		}

		for (int i = 0; i < 20; i++)
		{
			int flag6 = 0;
			int flag10 = 0;
			for (int j = 0; j < 20; j++)
			{
				double l;
				l = (h[i].x - h[j].x) * (h[i].x - h[j].x) + (h[i].y - h[j].y) * (h[i].y - h[j].y);
				l = sqrt(l);
				//printf("%lf\n", l);
				if (abs(l - 6.0) < 0.001)
				{
					pa.x = h[i].x;
					pa.y = h[i].y;
					p6.x = h[j].x;
					p6.y = h[j].y;
					flag6 = 1;
				}
				else if (abs(l - 9.0) < 0.001)
				{
					p10.x = h[j].x;
					p10.y = h[j].y;
					flag10 = 1;
				}
			}

			if (flag6 == 1 && flag10 == 1)
			{
				break;
			}
		}
		//printf("%lf, %lf\n", pa.x, pa.y);
		//printf("%lf, %lf\n", p6.x, p6.y);
		//printf("%lf, %lf\n", p10.x, p10.y);
		if (p6.y > pa.y)
		{
			if (p6.x > pa.x)
			{
				if (p10.y < pa.y)
				{
					printf("right\n");
				}
				if (p10.y > pa.y)
				{
					printf("left\n");
				}
			}
			if (p6.x < pa.x)
			{
				if (p10.y > pa.y)
				{
					printf("right\n");
				}
				if (p10.y < pa.y)
				{
					printf("left\n");
				}
			}
			if (p6.x == pa.x)
			{
				if (p10.x > pa.x)
				{
					printf("right\n");
				}
				if (p10.x < pa.x)
				{
					printf("left\n");
				}
			}
		}
		else if (p6.y < pa.y)
		{
			if (p6.x < pa.x)
			{
				if (p10.y > pa.y)
				{
					printf("right\n");
				}
				if (p10.y < pa.y)
				{
					printf("left\n");
				}
			}
			if (p6.x > pa.x)
			{
				if (p10.y < pa.y)
				{
					printf("right\n");
				}
				if (p10.y > pa.y)
				{
					printf("left\n");
				}
			}
			if (p6.x == pa.x)
			{
				if (p10.x < pa.x)
				{
					printf("right\n");
				}
				if (p10.x > pa.x)
				{
					printf("left\n");
				}
			}
		}
		else if (p6.y == pa.y)
		{
			if (p10.y < pa.y)
			{
				printf("left\n");
			}
			if (p10.y > pa.y)
			{
				printf("right\n");
			}
		}
	}
}
```
### [D. Points Construction Problem](https://ac.nowcoder.com/acm/contest/5668/D)

### **题意** 

有n个黑点，是否能组成，m个黑点白点相连的组合

### **思路** 

参考了(https://www.cnblogs.com/mauve-hkq/p/13336463.html)
可以转换为构成了多少条边：(4*m - n)/2
然后再进行构造。p.s.自己的代码并没有过，就不写了QAQ


### [E. Two Matchings](https://ac.nowcoder.com/acm/contest/5668/E)  

### **题意**  

给一个序列（含偶数个元素）
要找到两种完全不同的两两匹配，使得所有两两匹配的差的和最小，输出这个和。

### **思路**  

需要找到4个特性：  
1、此题等价于找一些长度为偶数的环使得这些环恰通过每个点一次， 且所有边的总权重最少。


2、 2k 个点所构成的环的权重和的最小值为最大的权重减最小的权重。


3、先把所有点的按照权重排序，最佳解一定是出现在每个环都是由排
。序后连续的点构成。


4、若某个环长度 ≥ 8，总是可以拆成一些长度为 4 或 6 的环且总边 权更小。


### **代码**  
```  
#include<iostream>
#include<stdio.h>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=2e5+5;
typedef long long ll;
int a[maxn];
ll dp[maxn];
const ll INF=1e18;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
    	scanf("%d",&n);
    	for(int i=1;i<=n;i++)
        	dp[i]=INF;
    	for(int i=1;i<=n;i++)
        	scanf("%d",&a[i]);
    	sort(a+1,a+1+n);
    	dp[0]=0;
	    for(int i=1;i<=n;i++)
	    {
	        if(i>=4) dp[i]=min(dp[i],dp[i-4]+2LL*(a[i]-a[i-4+1]));
	        if(i>=6) dp[i]=min(dp[i],dp[i-6]+2LL*(a[i]-a[i-6+1]));
	    }
    	printf("%lld\n",dp[n]);
	}
	return 0;
}
```  


### [F. Fraction Construction Problem](https://ac.nowcoder.com/acm/contest/5668/F)

### **题意**

每次给出$a,b$,求出$c,d,e,f$满足$\frac{c}{d}-\frac{e}{f}=\frac{a}{b}$

$a,b\leqslant2×10^{6}$

$d<b$, $f<b$

$1\leqslant c,e\leqslant4×10^{12}$

### **思路**
分情况讨论

**1.a,b不互质**

$m$为大于1的公因数，构造$c=\frac{a}{m}+1, d=f=\frac{b}{m}, e=1$

**2.a,b互质**

通分，$\frac{cf-ed}{df}=\frac{a}{b}$

- $b$是1/质数/质数的幂次，无解
- 将$b$分解成两个不相等质数的乘积，即$d,f$，此时用**扩展的欧几里得**找到满足式子$cf-ed=a$的$c,e$

### **证明**

要证a,b互质，b是1/质数/质数的幂次时无解

**证明：**

$b=1$时，显然

$b$为质数/质数的幂次，

设$b=p^{k}$, 由于$d,f<b$，设$d=p^{x}, f=p^{y}, x+y=k, x\neq 0, y\neq 0$，此时$\frac{cf-ed}{df}=\frac{cp^{y}-ep^{x}}{p^{k}}$，一定存在$gcd(x,y)$使得分式上下可约分，此时分母小于$p^{k}$；
而$a,b$互质无法约分，则左侧分母一定为$b$, 即$p^{k}$，产生矛盾，得证

### **代码**
```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cmath>
#include<math.h>
#include <iostream>
using namespace std;
typedef long long ll;
int gcd(int a, int b);
ll ex_gcd(int a, int b, ll& x, ll& y);
int main()
{
    int t, a, b;
    long long c, e, ans;
    scanf("%d", &t);
    while (t--) {
        scanf("%d%d", &a, &b);
        int m = gcd(a, b);
        if (m != 1)
            cout << a / m + 1 << " " << b / m << " " << 1 << " " << b / m << endl;
        else {
            int d = 0, f = 0;
            for (int k = 2; k*k <= b; k++) {
                if (b % k == 0 && gcd(k, b / k) == 1) {
                    d = k; f = b / k;
                     
                    break;
                }
            }
            if (d==0&&f==0) cout << "-1 -1 -1 -1" << endl;
            else {
                ans = ex_gcd(f, d, c, e);
                c =c*1ll*a, e =e*1ll*a;
                if (c > 0 && e < 0) printf("%lld %d %lld %d\n", c, d, -e, f);
                else printf("%lld %d %lld %d\n", e, f, -c, d);
 
 
                //cout << c << " " << e << endl;
            }
        }
    }
    return 0;
}

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
 
ll ex_gcd(int a, int b, ll& x, ll& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll ans = ex_gcd(b, a % b, x, y);
    ll temp = x;
    x = y;
    y = temp - a / b * y;
    return ans;
}
```

### [G. Operating on a Graph](https://ac.nowcoder.com/acm/contest/5668/G)

### **题意**

一个 n 个点的图，第 i 个点一刚开始是第 I 种颜色，进行如下操作：

- 每次操作输入颜色$o_i$ 表示$o_i$ 会侵略所有和自己相邻的颜色

- 如果图内不存在颜色$o_i$，此次操作无效

求最终每个点的颜色。

### **思路**

一旦经过一次操作后，某个点将自己相邻点的颜色变为自己同色，该点与相邻点永远同色

用**并查集**维护每个结点属于什么颜色

是用vector记录第i种颜色相邻的点，将y颜色相邻点加入到x颜色相邻点，且y集合颜色改为x颜色
### **代码**
```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cmath>
#include<math.h>
#include <iostream>
using namespace std;
typedef long long ll;
int fa[800005];
vector<int>list[800005];
int find(int x)
{
	if (x == fa[x])return x;
	else return fa[x] = find(fa[x]);
}
int main()
{

	int t, n, m, x, y, q, o, nxt;
	scanf("%d", &t);
	while (t--) {
		scanf("%d%d", &n, &m);
		for (int i = 0; i < n; i++) {
			fa[i] = i;
			list[i].clear();
		}
		for (int i = 0; i < m; i++) {
			scanf("%d%d", &x, &y);
			list[x].push_back(y);
			list[y].push_back(x);
		}
		/*for (int i = 0; i < n; i++)
			cout << fa[i] << " ";*/
		scanf("%d", &q);
		for (int i = 0; i < q; i++) {
			scanf("%d", &o);
			int fc = find(o);//父结点
			if (fc != o) continue;
			else {
				vector<int> a;
				a = list[fc];
				list[fc].clear();
				for (int j = 0; j < a.size(); j++) {
					//cout << a[j] << endl;
					nxt = find(a[j]);//遍历每个与它相邻的点
					if (nxt == fc) continue;
					if (list[fc].size() < list[nxt].size()) 
						swap(list[fc], list[nxt]);
					for (int k = 0; k < list[nxt].size(); k++)
						list[fc].push_back(list[nxt][k]);
					fa[nxt] = fc;
				}				
				
			}
		
		}
		for (int l = 0; l < n; l++)
			printf("%d ", find(l));
		printf("\n");
	}
	return 0;
}
```

### [L. Problem L is the Only Lovely Problem](https://ac.nowcoder.com/acm/contest/5668/L)

### **题意**

签到题，字符串以lovely(不分大小写)开头输出`lovely`,否则输出`ugly`
### **代码**
```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<string.h>
#include<cstring>
#include<string>
#include<stack>
using namespace std;
int main() {
	string s;
	cin >> s;

	if ((s[0] == 'l' || s[0] == 'L') && (s[1] == 'o' || s[1] == 'O') && (s[2] == 'v' || s[2] == 'V') && (s[3] == 'e' || s[3] == 'E') && (s[4] == 'l' || s[4] == 'L') && (s[5] == 'y' || s[5] == 'Y'))
		cout << "lovely" << endl;
	else
		cout << "ugly" << endl;
	return 0;
}
```

