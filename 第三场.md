#### 2020牛客暑假多校训练营第三场总结
##### 关于队伍
第一次组团打牛客的比赛，对环境还不是很熟悉，也因为之前的准备较少，使得团队合作效率变低。不过，也在不断磨合中进步。比赛期间重点关注的额是A、L题。其中L题是签到题，A题为一道模拟题。
##### 题目解析
###### A题解题思路
使用时间复杂度是O(n)的模拟。
在类型2与3时，直接抓鱼永远是最佳选择.
但是在类型0时，只能通过鱼饵抓鱼；类型1时，可以换鱼饵或者用鱼饵抓鱼。
所以，需要忽视前导0，在2或3时答案加1。后面遇到一个0，就尽可能使用鱼饵；遇到1，就先默认制作鱼饵，将现在拥有的鱼饵数量加1。
最后如果有剩余鱼饵>=，则可以设置为一次换鱼饵，一次抓鱼。 
```C++
#include<bits/stdc++.h>
using namespace std;
#define debug(x) cout<<"###"<<x<<"###"<<endl;
const int INF=0x3f3f3f3f,mod=1e9,Maxn=1e6;
typedef long long ll;
int main(){
    int t;
    cin>>t;
    int a;
    while(t--){
        stack<char> stk;
        string s;
        int n;
        cin>>n;
        int ans=0;
        cin>>s;
        for(int i=0;i<n;i++){
            if(s[i]=='1'){
                stk.push((s[i]));
            }
            if(s[i]=='2'){
                ans++;
            }
            if(s[i]=='3'){
                ans++;
            }
            if(s[i]=='0'){
                if(!stk.empty()){
                    stk.pop();
                    ans++; 
                }  
            }
        }
        int cnt=0;
        while(!stk.empty()){
            stk.pop();
            cnt++;
        }
        cout<<ans+cnt/2<<endl;
    }
    return 0;
}

```
###### B题解题思路
直接模拟操作过于复杂且会超时间。根据分析，可以将c为M时，X的正负情况可以转化为同一操作，即统一转化为将前面字符向后移。模拟过程中无需真正对字符串进行操作，而转化为通过加上偏移量进行寻找字符，这样可以简化模拟过程，降低时间与空间复杂度。
```C++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 2e6 + 19;
char s[maxn];
int main()
{
    scanf("%s",s);
    int len = strlen(s);
    int t;
    ll temp = 0;
    scanf("%d",&t);
    while(t--){
        char ch;
        int x;
        scanf(" %c%d",&ch,&x);
        if(ch == 'A') {
            printf("%c\n",s[((x + temp - 1) % len)]);//对应到原数组中
        }
        else{
            if(x > 0) temp += x;//temp为累积量
            else temp += (len + x);
        }
    }
    return 0;
}

```
###### C题解题思路
首先找到掌根（最长，为9），再顺势找到掌边（长为8/6）做向量叉乘即可判断左右手。
```C++
#include<bits/stdc++.h>
using namespace std;
struct node{double x,y;}a[22];
double eps=0.00001;
double le(node x,node y){return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));}//距离
double cj(node a,node b,node c){return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x);}//叉乘
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		bool f=0;
		for(int i=0;i<20;i++)
			scanf("%lf%lf",&a[i].x,&a[i].y);
		for(int i=0;i<20;i++)
		{
			if(fabs(le(a[i],a[(i+1)%20])-9.0)<eps)
			{
				node x=a[i],y=a[(i+1)%20],z=a[(i+2)%20];
				if(cj(x,y,z)>0&&fabs(le(y,z)-6)<eps||cj(x,y,z)<0&&fabs(le(y,z)-8)<eps)//两个掌边两种情况
					f=1;
				break;
			}
		}
		if(f)printf("left\n");
        else printf("right\n");
	}
}
```
###### F题解题思路
情况一：b=1或者b是质数时，一定无解(因为d<b且f<b).
情况二：gcd(a,b)!=1时，求出g=gcd(a,b)，一定存在一组解：c=a/g+1，d=b/g，e=1，f=b/g。

情况三：当gcd(a,b)=1，即ab互质时，因为这里b不是质数，可以分成两个相异质因数--d,f，所以要以b=df且d,f互质的条件找到d,f。
遍历2到sqrt(b)的素数，找出第一个被b整除的素数i，然后将f赋值为b/i。接下来要开始求出c,e。已知b=df，所以根据原方程可得a=c×f−e×d,求解c和e，就能用扩展欧几里得算法来求解c,e。在求出c和e之后要判断一下正负，通过c和e的正负性判断两个相异质因数分别对应谁。 
```C++
#include<bits/stdc++.h>
using namespace std;
int gcd(int a,int b)
{
	if(b==0) return a;
	return gcd(b,a%b);
}
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	long long s=exgcd(b,a%b,x,y),t=x;
	x=y,y=t-(a/b)*y;
	return s;
}
int main()
{
	int a,b,g,i,j;
	long long c,d,e,f,t,x;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&a,&b);
		g=gcd(a,b);
        if(g>1)
		{
            printf("%d %d %d %d\n",a/g+1,b/g,1,b/g);
            continue;
        }
        d=f=0;
        for(i=2;i*i<=b;i++)
            if(b%i==0 && gcd(i,b/i)==1)
			{
                d=i,f=b/i;
                break;
            }
        if(d==0 && f==0)
		{
            printf("-1 -1 -1 -1\n");
            continue;
        }
        c=e=0;
        x=exgcd(f,d,c,e);
        c*=a,e*=a;
        if(c>0 && e<0) printf("%lld %lld %lld %lld\n",c,d,-e,f);
        else printf("%lld %lld %lld %lld\n",e,f,-c,d);
	}
}
```
