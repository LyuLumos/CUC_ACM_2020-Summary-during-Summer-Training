
### [I.Interesting Computer Game](https://ac.nowcoder.com/acm/contest/5673/I)  

### **题意**  
每组数中给n组两个数，选取其中一个没取过的数，问当用最优的策略时，最多可选取多少个数。

### **思路**  
可以发现，ans=总共的数-没有成环的并查集数=对于每个并查集相加：该并查集中数字的个数-0(成环)|1(未成环)
折在的地方：
1.将数字编号(id[])，这样就可以将其限定在2e5中了
2.find_fa(int id)函数中，return fa[id] = find_fa(fa[id])，可节约时间，使其不超时

### **代码**  
```  
#pragma warning (disable:4996)
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <cmath>
#include <map>
#define inf 0X7f7f7f7f
#define MS_I(x) memset(x,-inf,sizeof(x))
#define MS(x) memset(x,0,sizeof(x))
#define MS_1(x) memset(x,-1,sizeof(x))
#define MSI(x) memset(x,inf,sizeof(x))
#define MOD 1e9 + 7
#define random(a,b) ((long long)rand()%(b-a+1)+a)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 2e5 + 20;

int n, t;
int fa[maxn], vis[maxn], siz[maxn];
int ar[maxn], br[maxn];
vector <int> v;

int get_id(int a)
{
	int temp = lower_bound(v.begin(), v.end(), a) - v.begin();
	return temp;
}
int find_fa(int id)
{
	if (fa[id] == id)
		return id;
	return fa[id] = find_fa(fa[id]);
}//优化在这里，！！！


int main()
{
	scanf("%d", &t);
	for (int r = 1; r <= t; r++)
	{
		scanf("%d", &n);
        for (int i = 0; i < 2 * n + 5; i++)
        {
            fa[i] = i;
            vis[i] = 0;
            siz[i] = 1;
        }
        v.clear();
		for (int i = 0; i < n; i++)
		{
			scanf("%d %d", &ar[i], &br[i]);
			v.push_back(ar[i]);
			v.push_back(br[i]);
		}

		sort(v.begin(), v.end());
		v.erase(unique(v.begin(), v.end()), v.end());
		int num = v.size();

		
		ll ans = 0;
		for (int i = 0; i < n; i++)
		{
			int ida = get_id(ar[i]);
			int idb = get_id(br[i]);
			int fa_a = find_fa(ida);
			int fa_b = find_fa(idb);
			if (fa_a == fa_b)
			{
				vis[fa_a] = 1;
			}
			else
			{
				fa[fa_b] = fa_a;
				siz[fa_a] += siz[fa_b];
				vis[fa_a] = vis[fa_a] | vis[fa_b];
			}
		}

		for (int i = 0; i < num; i++)
		{
			if (fa[i] != i)
			{
				continue;
			}
			ans += (siz[i] - 1 + vis[i]);
		}

		printf("Case #%d: %d\n", r, ans);
	}
}
```  






### [K.Kabaleo Lite](https://ac.nowcoder.com/acm/contest/5673/K)  

### **题意**  
n种食物，每个食物有自己的利润和个数，每次都从第一个食物取，问最多有几个用户，这时的最大利润是多少。

### **思路**  
用vector装某时的最大sum例如和其最小个数，然后再一个个pop()出来以计算。
折在的地方：
1.最后ans爆long long了，要用__int128
inline void write(__int128 x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
2.这种脑袋转不过来又没卡的那么严的情况就全用long long好了(笑，竟然折在ll和int上
 
### **代码**  
 ```
#pragma warning (disable:4996)
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <cmath>
#include <map>
#define inf 0X7f7f7f7f
#define MS_I(x) memset(x,-inf,sizeof(x))
#define MS(x) memset(x,0,sizeof(x))
#define MS_1(x) memset(x,-1,sizeof(x))
#define MSI(x) memset(x,inf,sizeof(x))
#define random(a,b) ((long long)rand()%(b-a+1)+a)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 1e5 + 20;
//const int maxm = 2e5 + 20;
const int mod = 1e14;
vector <ll> vm;
vector <ll> vg;
ll ar[maxn];
ll br[maxn];
inline void write(__int128 x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int main()
{
	int t;
	scanf("%d", &t);
	for (int r = 1; r <= t; r++)
	{
		int n;
		scanf("%d", &n);
		for (int i = 0; i < n; i++)
		{
			scanf("%lld", &ar[i]);
		}
		for (int i = 0; i < n; i++)
		{
			scanf("%lld", &br[i]);
		}
		ll sum = 0;
		ll ma = 0;
		ll mi = maxn;
		vm.clear();
		vg.clear();
		ll ans1 = br[0];
		for (int i = 0; i < n; i++)
		{
			mi = min(mi, br[i]);
			sum += ar[i];
            if (i == 0)
            {
                ma = sum;
                vm.push_back(sum);
				vg.push_back(mi);
            }
			else if (ma < sum)
			{
				ma = sum;
				vm.push_back(ma);
				vg.push_back(mi);
			}
		}
		ll gg = 0;
		__int128 ans = 0;
		while (!vm.empty())
		{
			ll g = vg.back();
			vg.pop_back();
			ll m = vm.back();
			vm.pop_back();
			ll g2;
			if (gg < g)
			{
				g2 = g - gg;
				gg = g;
				ans += (__int128)g2 * m;
			}
		}
		printf("Case #%d: %lld ", r, ans1);
		write(ans);
		puts("");
	}
}
```
