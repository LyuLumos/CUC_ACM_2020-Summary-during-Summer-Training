2020牛客多校第八场笔记

**Kabaleo Lite**

**贪心** **在客户量最大的基础上取最高利润** **注意到每道菜要连续选取，所以每道菜供应分量不超过前一道。** **注意输出结果会爆****long long** **可用****__128int**

**#include<bits/stdc++.h>**

**using namespace std;**

**const int maxn=1e5+5;**

**long long a[maxn],b[maxn];**

**__int128 s[maxn];**

**void print(__int128 x){**

​     **if(x<0) {**

​         **putchar('-');**

​         **x=-x;**

​     **}**

​     **if(x>9) print(x/10);**

​         **putchar(x%10+'0');**

**}**

**int main(){**

​     **int t,n;**

​     **cin>>t;**

​     **int c=1;**

​     **b[0]=maxn;**

​     **while(t--){**

​         **scanf("%d",&n);**

​         **for(int i=1;i<=n;i++){**

​             **scanf("%lld",&a[i]);**

​             **s[i]=s[i-1]+a[i];**

​         **}**

​         **for(int i=1;i<=n;i++){**

​             **scanf("%lld",&b[i]);**

​             **b[i]=min(b[i-1],b[i]);**

​         **}**

​         **__int128 x=s[1],ans=0;**

​         **for(int i=2;i<=n;i++){**

​             **if(b[i]<b[i-1]) ans+=(b[i-1]-b[i])\*x;**

​             **x=max(s[i],x);**

​         **}**

​         **ans+=x\*b[n];**

​         **printf("Case #%d: %lld ",c++,b[1]);**

​         **print(ans);**   

​         **printf("\n");**

​     **}**

​     **return 0;**

**}**

 

 

**[Interesting Computer Game](https://ac.nowcoder.com/acm/problem/210022)**

**并查集** **离散化**

**ai****和****bi****的取值范围是****-1e9****到****1e9** **直接对其值的大小维护并查集开销大** **可用****map****离散化** **记录每个数字首次出现时的下标** **并用并查集对下标进行维护** **最坏的情况是每组****a,b****的值都不同** **所以维护的数组****f[maxn] maxn****要开到****2\*n;**

**合并过程中** **如果成环可以全部取到** **如果有不能成环的取到的数目减一**

**#include<bits/stdc++.h>**

**using namespace std;**

**const int maxn=1e5+10;**

**int a[maxn],b[maxn],vis[maxn],f[maxn];**

**int c;**

**map<int,int> m;**

**void init(){**

  **for(int i=1;i<=c;i++){**

​    **f[i]=i;**

​    **vis[i]=0;**

  **}**

**}**

**int find(int x){**

  **if(f[x]!=x) f[x]=find(f[x]);**

  **return f[x];**

**}**

**void merge(int x,int y){**

  **int a=find(x);**

  **int b=find(y);**

  **if(a!=b){**

​    **f[a]=b;**

​    **if(vis[a]||vis[b]){**

​      **vis[b]=1;**

​      **vis[a]=0;**

​    **}**

  **}**

  **else vis[b]=1;**

**}**

**int main(){**

  **int n,t,k=1;**

  **cin>>t;**

  **while(t--){**

​    **c=1;**

​    **scanf("%d",&n);**

​    **memset(f,0,sizeof(f));**

​    **m.clear();**

​     **for(int i=0;i<n;i++){**

​      **scanf("%d%d",&a[i],&b[i]);**

​      **if(!m[a[i]])m[a[i]]=c++;**

​      **if(!m[b[i]])m[b[i]]=c++;**

​    **}**

​    **init();**

​    **for(int i=0;i<n;i++)**

​      **merge(m[a[i]],m[b[i]]);**

​    **int ans=c;**

​    **for(int i=1;i<=c;i++)**

​      **if((f[i]==i)&&!vis[i])**

​        **ans--;**

​    **printf("Case #%d: %d\n",k++,ans);**

  **}**

  **return 0;**

**}**