**Codeforces Education Round 93 div2 题解**

[Substring Removal Game](https://vjudge.net/problem/CodeForces-1398B)

博弈 算连续1的个数  奇数次为先手胜

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=105;
int a[maxn];
bool cmp(int x,int y){
	return x>y;
}
int main(){
	int t;
	cin>>t; 
	string s;
	while(t--){
		cin>>s;
		int k=1,cnt=0;
		memset(a,0,sizeof(a));
		int n=s.length();
		for(int i=0;i<n;i++){
			if(s[i]=='1') cnt++;
			if((s[i]=='0'||s[i+1]=='\0')&&cnt){
				a[k++]=cnt;
				cnt=0;
			}	
		}
		int ans=0;
		sort(a+1,a+1+k,cmp);
		for(int i=1;i<=n;i+=2){
			ans+=a[i];
		}
		printf("%d\n",ans);
	} 
	return 0;
}
```





## 

 [Good Subarrays](https://vjudge.net/problem/CodeForces-1398C)

思维 map维护前缀和

把每个数减一，转化为求和为零的子序列数 ，用map记录不同长度子序列的前缀和 前缀和相等ans加一，前缀和相同ans也加一（中间序列和为零）

ans爆int

```
#include<bits/stdc++.h> 
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,cnt=0;
		long long ans=0;
		cin>>n;
		string s;
		cin>>s;
		map<int,int> m;
		m.clear();
		for(int i=0;i<n;i++){
			cnt+=(s[i]-'0'-1);
			if(!cnt) ans++;
			ans+=m[cnt];
			m[cnt]++;
		}
		cout<<ans<<endl;
	}
	return 0;
} 


```



 [Colored Rectangles](https://vjudge.net/problem/CodeForces-1398D)

 dp

三种不同的木棒，第一种木棒有a对，第二种b对，第三种c对，每次取两对不同的木棒组成一个矩形，求最后组成的若干个矩形的面积最大和。 假设每种木棍已分别选择i,j,k个，任取两个，列出三个状态转移方程

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=205;
int ans;
int dp[maxn][maxn][maxn];
int a[maxn],b[maxn],c[maxn];
bool cmp (int x,int y) {return x>y;}
int main () {
    int A,B,C;
    scanf("%d%d%d",&A,&B,&C);
    for (int i=1;i<=A;i++) scanf("%d",&a[i]);
    for (int i=1;i<=B;i++) scanf("%d",&b[i]);
    for (int i=1;i<=C;i++) scanf("%d",&c[i]);
    sort(a+1,a+1+A,cmp);
    sort(b+1,b+1+B,cmp);
    sort(c+1,c+1+C,cmp);
    for (int i=0;i<=A;i++)
        for (int j=0;j<=B;j++)
            for (int k=0;k<=C;k++) {
                if (i&&j) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k]+a[i]*b[j]);
                if (i&&k) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k-1]+a[i]*c[k]);
                if (j&&k) dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]+b[j]*c[k]);
                ans=max(ans,dp[i][j][k]);
            }
    printf("%d\n",ans);
} 
```



 