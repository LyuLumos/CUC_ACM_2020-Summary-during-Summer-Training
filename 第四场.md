#### 2020牛客暑假多校训练营第四场总结
##### 关于队伍
有了上次团队做题的经验，这次对环境有所了解与把握。但感觉这次题目难度要大一些，只过了F题一道签到题目。理解错了B题题目的意思（跑偏了），事后看题解觉得思路还不是很难，D题有解题思路但不知道如何具体实现，参考了网上的代码实现~
##### 题目解析
###### B题解题思路
该函数的递归退出条件是gcd(i,x) == 1的时候，此时f(1) = 1。而f(x)的值是与gcd相关的，·所以需要统计x的质因子数量，通过找规律发现
答案是 c^f(n)，f(n) 为 n 的质因子个数(可重复)。
```C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
const ll N=1e6+10;
ll power(ll a,ll b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}//快速幂
ll prime[N],k,t,n,c;
bool isprime[N];
void Prime(){
    fill(isprime,isprime+N,1);
    k=0;
    prime[1]=0;
    for(ll i=2;i<N;i++){
        if(isprime[i]){
            prime[k++]=i;
            for(ll j=2;i*j<N;j++)
                isprime[i*j]=0;
        }
    }
}

ll solve(ll n){//统计素因子
    ll cnt=0,sum=0;
    for(ll i=0;i<k&&prime[i]*prime[i]<=n;i++){
        if(n%prime[i]==0){
            while(n%prime[i]==0){
                sum++;
                n/=prime[i];
            }
        }
    }
    if(n>1) sum++;
    return sum;
}

int main(){
    Prime();//素数打表
    scanf("%lld",&t);
    while(t--){
        scanf("%lld%lld",&n,&c);
        printf("%lld\n",power(c,solve(n)));
    }
}
```
###### D题解题思路
首先一下差最大为9（各个数拆分），因此，凡算出来的差大于等于9，就直接舍去。
接下来，我们分两种情况讨论：
1.若把这个数字串分成长度等的几个数字，则需要枚举n的质因数。然后只需要一个一个进行求差，若有一个差是大于等于9的，则这个整体的差也肯定大于等于9的，直接舍去就行，再枚举下一个质因数。
2.若把这个数字分成长度不相等的两个数字。这两个数字的数位差肯定是1，而且这两个数还满足以下的形式：
一个数：100……x，中间有若干个0，可能有0个0，最后一位肯定是0~7之间
另一个数：99……y，中间有若干个9，可能有0个9，最后一位肯定是2~9之间
所以，只要寻找1,就能找到这一整个数了，也能找到另一个数。
```C++
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
char s[MAXN];
int a[MAXN],b[MAXN],pr[MAXN],t,n,ans=9;
void DSJ(int* a,int *b,int n)//大数减
{
    for(int i=n;i;i--)a[i]-=b[i];
    for(int i=n;i;i--)if(a[i]<0)a[i-1]--,a[i]+=10;
}
bool cmp(int* a,int* b,int n)//比较两个大数的大小
{
    for(int i=1;i<=n;i++)if(a[i]!=b[i])return a[i]<b[i];
    return 0;
}
int solve_f(int len,int n)//所有数字位数相等的情况
{
    if(len>1&&!a[1])return 9;//如果有前导0，直接返回9
    int* mi=a,*mx=a;
    for(int i=0;i<n;i+=len)
	{
        if(len>1&&!a[i+1])return 9;//如果有前导0，直接返回9
        if(cmp(a+i,mi,len))mi=a+i;//更新最小值
        if(cmp(mx,a+i,len))mx=a+i;//更新最大值
    }
    memcpy(b,mx,sizeof(int)*(len+10));DSJ(b,mi,len);//拷贝并进行大数减
    for(int i=1;i<len;i++)if(b[i])return 9;
    //如果除了个位数，其他数位上也有大于0的数，则差必然大于10，返回9
    return b[len];
}
int solve_d(int len,int n)//数字位数相差1的情况
{
    int p=1,zero=0,nine=9;
    while(p<=n)
        if(a[p]==1)//若找到了一个数，1肯定是在0的前面
		{ 
            if(p+len>n||pr[p+len-1]-pr[p])return 9;
            //如果超出总的位数或后一位不是0，返回9
            zero=max(zero,a[p+len]);p+=len+1;//记录1000……的最后一位数
        }
        else//否则就是另一个数
		{
            if(p+len-1>n||pr[p+len-2]-pr[p-1]!=9*(len-1))return 9;
            //如果超出总的位数或后面不是有(len-1)个9，返回9
            nine=min(nine,a[p+len-1]);p+=len;//记录999……的最后一位
        }
    return 10-nine+zero;//返回求差后的值
}
int main()
{
	for(scanf("%d",&t);t--;ans=9)
	{
		scanf("%d%s",&n,s+1);
        for(int i=1;i<=n;i++)a[i]=s[i]-'0',pr[i]=pr[i-1]+a[i];
        //求前缀和，可以快速算出一个区间内所有数字的和
        for(int i=1;i<=n/2;i++)//求出所有情况的最小值
		{
            ans=min(ans,solve_d(i,n));
            if(n%i==0) ans=min(ans,solve_f(i,n));
        }
        printf("%d\n",ans);
    }
	return 0;
}

```
###### H题解题思路
首先1和大于n/2的素数一定没有匹配对象，可以直接忽略。
接下来考虑剩下的素数，倒序枚举每个素数p，找出所有未匹配的p的倍数，并且记下总数。 如果总数是偶数，那么这些数就可以完美两两匹配；否则留下2p（2的倍数最为常用，可以用于应对最后剩下的数），匹配其余的数。
最后只会留下一堆偶数，而它们两两都可以随意匹配。
```C++
#include<bits/stdc++.h>
using namespace std;
long long a[200010],b[200010];
int main()
{
    int t,n,x,ans,i,j;
    for(i=2;i<=200000;i++)
        if(b[i]==0)
            for(j=2*i;j<=200000;j+=i) b[j]=1;
    scanf("%d",&t);
    while(t--)
    {
        ans=0;
        scanf("%d",&n);
        for(i=2;i<=n;i++) a[i]=0;
        for(i=n;i>=2;i--)
            if(!b[i])
            {
                x=i;
                for(j=n/i*i;j>i;j-=i)
                {
                    if(a[j]) continue;
                    if(x==0) x=j;
                    else ans++,a[x]=j,a[j]=x,x=0;
                }
            }
        printf("%d\n",ans);
        for(i=2;i<=n;i++)
            if(a[i]>i) printf("%d %d\n",i,a[i]);
    }
}

```
