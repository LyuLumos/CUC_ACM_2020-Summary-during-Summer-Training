### [B. Basic Gcd Problem](https://ac.nowcoder.com/acm/contest/5669/B)


### **题意**  

输入不同的$n,c$，求$f_c(n)mod(10^9+7)$

$f_c(x)=\underset{i=1...x-1}{max}(gcd(i,x))$&ensp;&ensp;&ensp; $x>1$

$f_c(x)=1$&ensp;&ensp;&ensp; &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;x=1
### **思路**  

设x的质因子个数为m, 则
$f_c(x)=c^m$

首先计算质因子个数，其次快速幂相乘

### **代码** 
```
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<vector>
#include<map>
using namespace std;
ll qmod(ll a, int b, ll c)//快速幂
{
    int r = 1;
    while (b)
    {
        if (b & 1) r = a * r % c;
        a = a * a % c;
        b >>= 1; //b的二进制形式删除最后一位
    }
    return r;
}
//质因数的个数
int countfactor(int number) {
    int count = 0;
    for (int i = 2; i * i <= number; i++) {
        while (number % i == 0) {
            count++;
            number = number / i;
        }
    }
    if (number != 1) {
        count++;
    }
    return count;
}
 
int main()
{
    int t;
    scanf("%d", &t);
    ll k = 1e9 + 7;
    while (t--)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        int s = countfactor(a);
         
        ll ans = qmod(b, s, k);
        printf("%lld\n", ans);
    }
}
``` 

### [F.  Finding the Order ](https://ac.nowcoder.com/acm/contest/5669/F)


### **题意**  

给定AC,AD,BC,BD的距离，判断AB//CD还是AB//DC

### **思路**  

以最长边为判断依据，如果最长边出现在AC/AD处，当AC>AD时，AB//DC，反之AB//CD；如果最长边出现在BC/BD处，当BC>BD时，AB//CD，反之AB//DC

### **代码** 
```
#include<iostream>
#include<stdio.h>
using namespace std;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int a[5],i;
        int maxn;
        for(i=0;i<4;i++)
        {
            scanf("%d",&a[i]);
        }
        maxn=a[0];
        for(i=1;i<4;i++)
        {
            if(a[i]>maxn)
            {
                maxn=a[i];
            }
        }
        if(maxn==a[0]||maxn==a[1])
        {
            if(a[0]<a[1])printf("AB//CD\n");
            else printf("AB//DC\n");
        }
        else
        {
            if(a[2]>a[3])printf("AB//CD\n");
            else printf("AB//DC\n");
        }
    }
    return 0;
}
```

### [H.  Harder Gcd Problem ](https://ac.nowcoder.com/acm/contest/5669/H)


### **题意**  

给定N,在1-N中选出最多的匹配对数，每对数的gcd>1

### **思路**  

遍历1-n/2以内的素数,枚举素数的倍数（未被匹配过）,如果个数为偶数，两两匹配；如果为奇数，留下2*p的元素

### **代码**
```
#include<cstdio>
#include<iostream>
using namespace std;
#pragma warning(disable:4996)


const int N = 200005;
int notprime[N], a[N];
void init() {
    for (int i = 2; i <= N; i++) {
        if (!notprime[i]) {
            for (int j = 2 * i; j <= N; j += i) notprime[j] = 1;
        }
    }
}
int main()
{
    int t,x,n;
   scanf("%d",&t);
   init();//标记素数
   while (t--) {
       scanf("%d", &n);
       int f = 0;
       int cnt = 0;
       for (int i = 1; i <= N; i++)
           a[i] = 0;
       for (int i = n / 2; i >= 2; i--) {//遍历n/2以内的素数
           //cout<<i<<endl;
           if (!notprime[i]) {//如果是素数
                 //cout<<i<<endl;
               f = i;
               for (int j = n / i * i; j > i; j -= i) {//j是n以内最大的素数的倍数
                   if (a[j]) continue;
                    
                   if (f == 0) {
                       f = j;
                   }
                   else {
                       cnt++;
                       a[j] = f;
                       a[f] = j;
                       f = 0;
                   }
               }
           }
       }
       cout << cnt << endl;
       for (int i = 2; i <= n; i++) if (a[i] > i) cout << i << " " << a[i] << endl;
   }
   return 0;
  
}
```