# 2020牛客暑假多校训练第十场题解

## A Permutation

**题目描述：**

给出一个素数p，要求你找出一个1~p - 1的排列满足对于任意一个i：
$$
x_{i+1}\equiv2x_i\pmod p x 或者 x_{i+1}≡3x_{i}(modp)
$$
**题解：**

其实就是，先找2的序列然后如果不合适换3，如果都不合适那就退出

**AC代码**

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn = 1e6 + 17;
int a[maxn] = {},num[maxn] = {};
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int p,flag = 1;
        memset(a,0,sizeof(a));
        memset(num,0,sizeof(num));
        scanf("%d",&p);
        a[1] = 1;num[1] = 1;
        for(int i = 2;i <= p - 1;i++){
            a[i] = a[i - 1] * 2 % p;
            if(!num[a[i]]) num[a[i]] = 1;
            else{
                a[i] = a[i - 1] * 3 % p;
                if(num[a[i]] == 1) flag = 0;
            }
        }
        if(!flag) printf("-1\n");
        else{
            for(int i = 1;i < p - 1;i++) printf("%d ",a[i]);
            printf("%d\n",a[p - 1]);
        }
    }
    return 0;
}
```

## G.Game

**题目描述：**

就是推箱子的改版。但是要求只能从左向右推，要求推完之后方块的最大高度最小。

**题解：**

类似于贪心的思想，每次我们遇到比当前最大高度高的方块我们就重新组合，可以知道的是，只要方块数量一定，能摆出的最低高度就一定是确定的，所以就一次次往前面推就可以了。

**AC代码：**

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
const int maxn = 2e5 + 10;
int b[maxn] = {};
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        int n,maxx = 0;
        ll sum = 0;
        scanf("%d",&n);
        for(int i = 1;i <= n;i++) scanf("%d",&b[i]);
        maxx = b[1];
        sum += b[1];
        for(int i = 2;i <= n;i++){
            sum += b[i];
            if(b[i] > maxx){
                int cnt = sum / i;
                if(sum % i != 0) cnt++;
                maxx = max(maxx,cnt);
            }
        }
        printf("%d\n",maxx);
    }
    return 0;
}
```

