### [A. Permutation](https://ac.nowcoder.com/acm/contest/5675/A)


### **题意**  
给定素数p，构造一个全排列，满足$x_{i+1}=2x_i（modp)$或者$x_{i+1}=3x_i（modp)$
### **思路**  
贪心

从1开始，先乘以2，如果遍历过就乘以3，总数不足则输出-1



### **代码** 
```
#pragma warning (disable:4996)
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <cmath>
#include <map>
#define inf 0X7f7f7f7f
#define MS_I(x) memset(x,-inf,sizeof(x))
#define MS(x) memset(x,0,sizeof(x))
#define MS_1(x) memset(x,-1,sizeof(x))
#define MSI(x) memset(x,inf,sizeof(x))
#define random(a,b) ((long long)rand()%(b-a+1)+a)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 1e6 + 20;
ll t, p;
ll vis[maxn];
ll two[maxn];
vector <ll> v;
const int mod = 1e9 + 7;
int main()
{
	ll j = 1;
	ll num = 0;
	while (j <= 1e6)
	{
		two[num++] = j;
		j <<= 1;
	}
	scanf("%lld", &t);
	while (t--)
	{
		scanf("%lld", &p);
		v.clear();
		memset(vis, 0, sizeof(vis));
		ll cnt = 1;
		ll l = 1;
		ll flag;
		ll ff = 1;
        v.push_back(1);
        vis[1]=1;
		while (cnt < p - 1)
		{
			flag = 0;
			ll temp = l * 2 % p;
			if (!vis[temp])
			{
				flag = 1;
				v.push_back(temp);
				vis[temp] = 1;
				cnt++;
				l = temp;
				continue;
			}
			temp = l * 3 % p;
			if (!vis[temp])
			{
				flag = 1;
				v.push_back(temp);
				vis[temp] = 1;
				cnt++;
				l = temp;
				continue;
			}
			if (!flag)
			{
				ff = 0;
				break;
			}
		}
		if (!ff)
		{
			printf("-1\n");
			continue;
		}
		for (ll i = 0; i < cnt; i++)
		{
			printf("%lld%c", v[i], i == cnt - 1 ? '\n' : ' ');
		}
	}
}

```

### [E. Game](https://ac.nowcoder.com/acm/contest/5675/E)


### **题意**  

将木箱从右向左推（只能向左），箱子会因重力作用而下落，使所有列最高的高度值最小

### **思路** 

法一：每次找到最高的高度，计算该处以前所有块的平均值，循环操作直到木箱无法向左推为止。最后求所有平均值中的最大值

法二：求最大的前缀平均值(好绝...)
### **代码** 
```
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <cmath>
#include <map>
#define inf 0X7f7f7f7f
#define MS_I(x) memset(x,-inf,sizeof(x))
#define MS(x) memset(x,0,sizeof(x))
#define MS_1(x) memset(x,-1,sizeof(x))
#define MSI(x) memset(x,inf,sizeof(x))
#define random(a,b) ((long long)rand()%(b-a+1)+a)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 1e5 + 20;
int t, n;
int mm[maxn];
int ar[maxn];
queue <ll> q;
const int mod = 1e9 + 7;
int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d", &n);
		while (!q.empty())
		{
			q.pop();
		}
		for (int i = 0; i < n; i++)
		{
			scanf("%d", &ar[i]);
		}
		ar[n] = 0;
		ll sum = 0;
		ll num = 0;
		for (int i = 0; i < n; i++)
		{
			sum += (ll)ar[i];
			num++;
			if (ar[i] > ar[i + 1])
			{
				
				ll tmp = ceil((double)sum / num);
				//printf("%lld\n", tmp);
				q.push(tmp);
				q.push(num);
				q.push(sum);
				sum = 0;
				num = 0;
			}
		}
		q.push(0);
		q.push(0);
		q.push(0);
		q.push(-1);
		sum = 0;
		num = 0;
		ll mx = 0;
		int flag = 1;
		while (!q.empty())
		{
			ll tmp = q.front();
			//printf("%lld\n", tmp);
			q.pop();
			if (tmp == -1)
			{
				//printf("!%lld\n", tmp);
				if (!flag)
				{
					q.push(0);
					q.push(0);
					q.push(0);
					q.push(-1);
					mx = 0;
					flag = 1;
					sum = 0;
					num = 0;
					continue;
				}
				else
					break;
			}
			ll nn = q.front();
			q.pop();
			ll ss = q.front();
			q.pop();
			
			if (tmp > mx)
			{
				if(mx != 0)
					flag = 0;
				mx = tmp;
				sum += ss;
				num += nn;
			}
			else
			{
				ll temp = ceil((double)sum / num);
				q.push(temp);
				q.push(num);
				q.push(sum);
				mx = tmp;
				sum = ss;
				num = nn;
			}
			
		}
		ll ans = q.front();
		printf("%lld\n", ans);
	}
}


```


