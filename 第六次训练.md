#### 自主训练第六场（div2 #665重现）
##### 题目解析
###### A题题意
在OX轴上，给出点A的坐标x=n，给出一个值k，求问能不能在OX轴上找一个点B，使得你|OA-AB|=k。如果不能找到，你每次可以将A点的坐标+1或-1，求至少移动点A多少次，使得可以找到点B（开始就能找到，输出0 ）。
解题思路：设B点坐标为y,则|OA-AB|=|2n-y|,即|2n-y|=k。如果n>k,则B在OA段内，需要进一步判断(n-k)%2;而若n<k,则B只能在A右侧。
难度：*
```C++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int t;
    scanf("%d",&t);
    while(t--){
    int n,k;
    cin>>n>>k;
    if(n>k){
    if((n-k)%2==0){cout<<0<<endl;}
    else cout<<1<<endl;
    }
    else cout<<k-n<<endl;
    }
    return 0;
}
```
###### B题题意
有两个数组a和b，这两个数组都只会有3个值：0或1或2。现在告诉你这两个数组中这三个值的数量。请你构造a,b数组，并且由下面规则生成c数组，并且使得c数组每一项的和最大，求这个最大值。规则：
ci =aibi  if ai>bi;
ci =0 	  if ai=bi;
ci =-aibi if ai<bi;
解题思路：贪心算法，a=2尽可能多得与b=1配对；让b=2尽可能与a=2,a=0配对,有多余则与a=1配对。
难度：**
```C++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int t;
    cin>>t;
    while(t--){
    int a[2],b[2],c[2];
    for(int i=0;i<2;i++){cin>>c[i]>>b[i]>>a[i];}
    int l=a[0]+b[0]+c[0];
    int sum=0;
    int a2=min(a[0],b[1]);
    sum=sum+2*a2;
    a[0]-=a2;b[1]-=a2;
    int a0=min(aa[0],a[1]);
    a[0]-=a0;a[1]-=a0;
    int c0=min(c[0],a[1]);
    a[1]-=c0;
    sum-=a[1]*2;
    cout<<sum<<endl;
    }
}
```

###### C题题意
给出长度为$n$的数组，每个数都大于1。记数组中最小的数为minn，现在你可以将数组中任意两个$gcd=minn$的数进行交换。求有没有可能使得整个数组变成不下降序列。
解题思路：可以判断出：数x交换的充分必要条件是x%minn==0.
难度：**
```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e7+10;
ll a[maxn];
ll b[maxn];
int main()
{
  int t;
	cin>>t;
	while(t--)
	{
		ll minn=2e13;
		bool flag=1;
	    int n;
		cin>>n;
		for(int i=0;i<n;i++){scanf("%d",&a[i]);b[i]=a[i];minn=min(minn,a[i]);};
		sort(b,b+n);
		for(int i=0;i<n;i++){
		if(a[i]!=b[i]&&a[i]%minn!=0)flag=0;
		};
		if(flag)cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
		
	}
	
}
```
###### D题题意：
给出一棵树，但没有边权。给出一个数的因数形式（给出的数的乘积为k）。
现在你需要给每一条边赋值，使得所有每两个点之间通过的路径和最大，且边权需要满足以下要求：
1.每条边的边权必须大于0;
2.所有边的边权之积为k;
3.边权为1的边的数量尽可能地少.
解题思路：参考别人的做法（一见到数就晕）首先贪心想法一定是通过最多次数的边赋值最大，最少次数的边赋值最小。具体通过树形dp求出每条边的通过次数，对于一条边i，它的通过次数等于它的子树大小*(n-它的子树大小)。然后再运用贪心算法求解。

难度： 4*
```C++
#include<bits/stdc++.h>
#include <bits/stdc++.h>
using namespace std;
const int maxn=200005;
const long long mod=1e9+7;
int T,n,head[maxn],k=0,size[maxn],tot,m;
struct node
{
	int to,next;
} edge[maxn<<1];
void add(int u,int v)
{
	edge[++k].to=v;
	edge[k].next=head[u];
	head[u]=k;
}
long long p[maxn],ans=0,b[maxn];
void dfs(int x,int fa)
{
	size[x]=1;
	for(int i=head[x];i;i=edge[i].next)
	{
		if(edge[i].to==fa) continue;
		dfs(edge[i].to,x);
		size[x]+=size[edge[i].to];
		b[++tot]=(long long)size[edge[i].to]*(long long)(n-size[edge[i].to]);
	}
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		memset(head,0,sizeof(head));k=0;tot=0;ans=0;
		scanf("%d",&n);
		for(int i=1,x,y;i<n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);add(y,x);
		}
		scanf("%d",&m);
		for(int i=1;i<=m;i++) scanf("%lld",&p[i]);
		dfs(1,1);
		sort(b+1,b+tot+1);
		sort(p+1,p+m+1);
		p[0]=1ll;
		while(m>tot)
		{
			p[m-1]=(p[m-1]*p[m])%mod;
			m--;
		}
		int pp=m;
		for(int i=tot;i;i--)
		{
			b[i]%=mod;
			ans=(ans+(b[i]*p[pp])%mod)%mod;
			pp--;
			if(pp<0) pp=0;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```
