#### 自主训练第三场（div2 #516重现）
##### 题目解析
###### A题题意
给定三个整数表示三角形的边。每次给边长可以加一，问至少要加多少才能使这三个边成为一个三角形。
解题思路：找到三条边中的最长边，根据两边之和大于第三边的条件，用最长边减去其他两边之和，如果结果是负数就返回0，否则将最长边加1再继续判断。
难度：*
###### B题题意
求满足式子a−(a xor x)−x=0的x值的数量（a<=2^30−1)
解题思路：即a-x=(a xor x)，可以发现规律：对于某一位的a和x设a这一位上的数字为ai，x这一位上的数字为xi，对于ai=0，只有xi=0才成立；对于ai=1，xi=0或者xi=1均成立.
难度：**
```C++
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int t,ans;
    scanf("%d",&t);
    while(t--){
    ans=1;
    ll n;
    cin>>n;
    while(n!=0){
    if(n%2==1){ans*=2;}
    }
    n/=2;
    };
    cout<<ans<<endl;
    return 0;
}
```

###### C题题意
给定一个字符串，使得他的是回文的子串数目最多，问应如何重新排列这个字符串。
解题思路：直接将所有一样的数排列在一起，就可以排出最大的回文串。
难度：**
```C++
#include <bits/stdc++.h>
using namespace std;
string b="abcdefjhijklmnopqrstuvwxyz"
int main() {
    int n;
    int a[30];
    memset(a,0,sizeof(a));
    scanf("%d",&n);
    string s;
    cin>>s;
    int cnt=0;
    for(int i=0;i<n;i++)
    {a[s[i]-'a']++;}
    for(int i=0;i<26;i++)
    {
    for(int j=0;j<a[i];j++)cout<<b[i];
    }
}
```
###### D题题意：
一个n*m的格子，有的格子有障碍不能经过。现在从（r, c）处出发，向左最多只能走x次，向右最多走y次，问可以到达的格子有多少个。
解题思路：迷宫bfs典型，做题时没有想到如何更好地表述点是否被访问和如何表述向左/右剩余最大次数，搜题解后得知可以用双端队列，向上走或向下走时就将该点push到队头，向左走或向右走时就将该点push到队尾，先按列方向处理，以保证给某个点标记当前剩余的向左走和向右走的最大次数。

难度：3*
```C++
#include<bits/stdc++.h>
#include <bits/stdc++.h>
using namespace std;

char d[2005][2005];

struct node
{
    int x, y, l, r;

};

deque<node> dq;
int main()
{
    int n, m, x, y, l, r, s=0;
    scanf("%d%d",&n,&m);
    scanf("%d%d",&x,&y);
    scanf("%d%d%*c",&l,&r);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            scanf("%c",&d[i][j]);
        }
        scanf("%*c");
    }
    node p;
    p.x=x-1, p.y=y-1, p.l=l, p.r=r;
    dq.push_front(p);
    d[x-1][y-1]='*';
    while(!dq.empty())
    {
        p=dq.front();
        dq.pop_front();
        int x, y, l, r;
        x=p.x+1, y=p.y;
        if(x<n&&d[x][y]=='.')//向上
            d[x][y]='*',s++,dq.push_front(node{x, y, p.l, p.r});
        x=p.x-1, y=p.y;
        if(x>=0&&d[x][y]=='.')//向下
            d[x][y]='*',s++,dq.push_front(node{x, y, p.l, p.r});
        x=p.x, y=p.y-1;
        if(y>=0&&p.l>=1&&p.r>=0&&d[x][y]=='.')//向左
            d[x][y]='*',s++,dq.push_back(node{x, y, p.l-1, p.r});

        x=p.x, y=p.y+1;
        if(y<m&&p.r>=1&&d[x][y]=='.')//向右
            d[x][y]='*',s++,dq.push_back(node{x, y, p.l, p.r-1});

    }
    cout<<s+1<<endl;//起点+1

    return 0;
}


```
