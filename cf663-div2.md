# cf663



https://codeforces.com/contest/1391

A

给定一个序列，包含n个元素，每个元素都是[1,*n*][1,n]中唯一的元素。求是否存在一个序列满足，对于任意的子序列，其中的每个数或起来大于这个区间的长度。

a|b >= max(a,b)，题目要求输出合要求的序列，举例发现从1到n输出就行。

B

给一个矩阵，元素为R说明能向右，D说明能向下，问至少改变几个元素能确保任意起点出发都能到达(n,m)；

题目要求不能出边界，统计边界上不合要求的元素数量，其他不用改，最后都会到达边界，只要确保边界正确就行。

```
#include<bits/stdc++.h>
using namespace std;
const int mxn = 150;
char s[mxn][mxn];
int main()
{
	int T;cin>>T;
	while(T--)
	{
		int n,m,ans = 0;
		cin>>n>>m;
		for(int i = 1;i<=n;i++)
		{
			for(int j = 1;j<=m;j++)
			{
				cin>>s[i][j];
			}
			
		}
		for(int i = 1;i<=n-1;i++)if(s[i][m]=='R')ans++;
		for(int i = 1;i<=m-1;i++)if(s[n][i]=='D')ans++;
		printf("%d\n",ans);
	}
	return 0;
}
```

C

对于一个序列，包含n个元素，每个元素都是[1,*n*][1,n]中唯一的元素。

连边条件如下

[![dVpcLt.md.png](https://s1.ax1x.com/2020/08/16/dVpcLt.md.png)](https://imgchr.com/i/dVpcLt)

引用下别人的博客讲解。。（https://lemonaaaaa.com/2020/08/codeforces-round-663-div2/）

显然总方案数为n!，那么现在考虑不满足要求的方案数。前面说到只要存在一个小的在中间，两边存在两个比它大的就行。那么我们就考虑最大的数，也就是n的位置。

- 将n放第1个位置，左边放0个数，右边放n-1个数，且顺序必须是从大到小，所以方案数为C(n-1,0)
- 将n放第2个位置，左边放1个数（从n-1个数中选1个），右边放n-2个数，且两边顺序必须是从n的位置开始，向两边从大到小排列（合唱队形），所以方案数为C(n-1,1)
- 将n放第3个位置，左边放2个数（从n-1个数中选2个），右边放n-3个数，且两边顺序必须是从n的位置开始，向两边从大到小排列（合唱队形），所以方案数为C(n-1,2)
- 将n放第n个位置，左边放n-1个数（从n-1个数中选n-1个），右边放0个数，且两边顺序必须是从n的位置开始，向两边从大到小排列（合唱队形），所以方案数为C(n-1,n-1)

求和后就是（i=0 ~ i=n-1）c（n-1，i）