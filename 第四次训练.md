# 第四次训练

## [A - Boboniu Likes to Color Balls](https://vjudge.net/problem/CodeForces-1395A)

​		题意：给出四个字母分别的数量，可以进行一种操作，将r g b各减1然后w加三，判断能否够成回文。

​		解题思路：想要构成回文，跟四个数的奇偶性有关。当四个数都为偶数或者三偶一奇时可以构成回文，两偶两奇时不能构成，三奇一偶则要按情况讨论。

```c++
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--){
		int a[4];
		cin>>a[0]>>a[1]>>a[2]>>a[3];
		int ans = 0;
		for(int i = 0; i < 4; i++){
			ans = ans + (a[i] % 2);
		}
		if(ans <= 1 || ans == 4){
			cout<<"YES"<<endl;
		}
		else if(ans == 3){
			if(a[0] > 0 && a[1] > 0 && a[2] > 0 ) 						cout<<"YES"<<endl;
			else cout<<"NO"<<endl;
		}
		else cout<<"NO"<<endl;
	}
}
```

## [B - Boboniu Plays Chess](https://vjudge.net/problem/CodeForces-1395B)

​		题意：一个n*m的网格，从起点（x,y)出发，可以上下左右移动，输出路径。

​		解题思路：模拟访问路线然后输出即可。从初始位置开始遍历。

```c++
#include<iostream>
using namespace std;
const int N=110;
int x,y;
int main()
{
    int i,j,n,m,k;
    cin>>n>>m>>x>>y;
    k = x - 1;
    for(i = y;i <= m; i++)
        cout<<x<<" "<<i<<endl;
    for(i = y-1;i >= 1; i--)
        cout<<x<<" "<<i<<endl;
    int flag = 0;
    while(k >= 1)
    {
        if(flag == 0)
        {
            for(i = 1;i <= m; i++)
                cout<<k<<" "<<i<<endl;
            flag = 1;
            k--;
        }
        else
        {
            for(i = m;i >= 1; i--)
                cout<<k<<" "<<i<<endl;
            flag = 0;
            k--;
        }
    }
    k= x + 1;
    while(k <= n)
    {
        if(flag == 0)
        {
            for(i = 1;i <= m; i++)
                cout<<k<<" "<<i<<endl;
            flag = 1;
            k++;
        }
        else
        {
            for(i = m;i >= 1; i--)
                cout<<k<<" "<<i<<endl;
            flag = 0;
            k++;
        }
    }
}
```

## [C - Boboniu and Bit Operations](https://vjudge.net/problem/CodeForces-1395C)

​		题意：给出两个已知长度的序列a和b，构造一个新序列c，其中ci = ai & bj，bj为b序列中任意元素并可多次使用。要求c1|c2|...|cn的值最小并给出答案。

​		解题思路：题目给的数据范围很小，直接暴力求解，当c[i] | x == x时即为所求解。

```c++
#include<iostream>
using namespace std;
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 0;i < n; i++) cin>>a[i];
    for(int i = 0;i < m; i++) cin>>b[i];
    for(int k = 0;k < 512; k++){
        int flag = 0;
        for(int i = 0;i < n; i++){
            int f = 0;
            for(int j = 0;j < m; j++){
                if((k|(a[i] & b[j])) == k){
                    f=1;break;
                }
            }
            if(!f){
                flag = 1;
                break;
            }
        }
        if(!flag){
            cout<<k;
            break;
        }
    }
    return 0;
}
```

## [D - Boboniu Chats with Du](https://vjudge.net/problem/CodeForces-1395D)

​		题意：有n天，每天有一个数值，如果这个数值大于m，则之后的d天会禁言，求最大值。

​		解题思路：枚举，前缀和。将大于m的和小于等于m的值分开存放在b、a两个数组，若拿取x个大于m的，其中有一个放在最后一个位置，那么消耗的a数组个数就是（x-1)*（d+1） + 1天，剩下的天数就在a中取最大的几个。

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int a[100020], b[100020];
ll pre[100020], pre2[100020];
int l1 = 0,l2 = 0;
ll n,d,m;
bool cmp(int a,int b)
{
	return a > b;
}
int main()
{
	cin>>n>>d>>m;
	for(int i = 1;i <= n; i++)
	{
		ll x; 
		cin>>x;
		if(x <= m)	a[++l1] = x;
		else	b[++l2] = x;
	}
	sort(a+1, a+l1+1, cmp);
	sort(b+1, b+l2+1, cmp);
	for(int i = 1;i <= l1; i++)	
		pre[i] = pre[i-1] + a[i];
	for(int i = 1;i <= l2; i++)	
		pre2[i] = pre2[i-1] + b[i];
	ll ans = pre[l1];
	for(int i = 1; i <= l2; i++){//枚举用了几个b数组的数
		ll p = 1ll * (i-1) * d + i;
		if(p > n) continue;
		ll k = max(0ll,1ll * (i-1) * d - (l2 - i));//k表示消耗的a的个数，l2-i是消耗的b数组里的，因为可能剩下的b比较多，不消耗a，跟0取个最大值
		ll tmp= pre2[i];//禁言部分的价值
		tmp += pre[l1 - k];//a剩余部分的价值，k表示消耗的a的个数
		ans = max(ans,tmp);
	}
	cout<<ans<<endl;
} 
```

