# 2020牛客暑假多校集训第九场题解

## A  Groundhog and 2-Power Representation

**题目描述：**

其实就是给出一个计算式的emmmm括号表达方法？

比如 
$$
137 = 2^7 + 2^3 + 2^0
$$
那么用给定的表达式描述就是 ：
$$
137=2(2(2)+2+2(0))+2(2+2(0))+2(0)
$$
现在给出你这样的表达式，让你求出它的值是多少。

**题解：**

队友写的python,pynb!

**AC代码:**

```python
s = input()
l =len(s)
cnt=0
while(cnt<len(s)):
    if s[cnt]=='(':
        m=s[:cnt]+"**"+s[cnt:]
        s=m
        cnt+=2
    cnt+=1

print(eval(s))
```

## F  Groundhog Looking Dowdy

**题目描述：**

给了你n类衣服，每一类衣服都对应一个或者多个时髦度，现在需要你选择m件不同的衣服，并且选择对应的时髦度，使得这m个时髦度的极差最小。

**题解：**

尺取法~~~~

我们维护一个长度为m的尺子，不断找不同衣服对应的时髦度，然后不断更新最小值。具体的看代码注释吧

**AC代码：**

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn = 2e6 + 17;
int vis[maxn] = {0};
struct Node{
    int x,line;
}N[maxn];
bool cmd(Node a,Node b)
{
    return a.x < b.x;
}
int main()
{
    int n,m,num = 0;
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i++){
        int k;
        scanf("%d",&k);
        for(int j = 1;j <= k;j++){
            scanf("%d",&N[++num].x);
            N[num].line = i;
        }
    }
    sort(N + 1,N + 1 + num,cmd);
    int l = 1,r = m,temp = 0,ans = 0x3f3f3f3f;
    for(int i = l;i <= r;i++){ //这一步操作的意思就是：我们维护一个满足m长度的尺子，而且这里面的衣服不是同一种
        if(!vis[N[i].line]) {
            vis[N[i].line]++;
            temp++;
        }
    }
    while(temp < m){ //如果1—m不满足，那么我们就可以拓展右端点
        r++;
        if(!vis[N[r].line]) {
            vis[N[r].line]++;
            temp++;
        }
    }
    for(l,r;l <= r && r <= num;){ //尺取法操作
        ans = min(ans,N[r].x - N[l].x); //维护最小值
        vis[N[l].line]--;l++;
        if(vis[N[l - 1].line] == 0) temp--; //如果上一件衣服只有一个时髦值，那么总的件数要减一
        while(r <= num && temp < m){
            r++;
            if(!vis[N[r].line]) {
                vis[N[r].line]++;
                temp;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

## I The Crime-solving Plan of Groundhog

**题目描述：**

题目就是说给你n个数，然后让你组成两个数，使他们的乘积最小。

**题解：**

首先对于n个数而言，一定是1位数乘n-1位数最小。

而那个一位数显然就应该是最小的那个数了，那么剩下的n-1位数的排列就应该是：最小的放在最高位，然后排0，排完0再按照从小到大的顺序放。

但是注意这个题是1e6的位数，所以要考虑用高精度的思想做，这个题卡时间卡的很严格，`vector`貌似会T回来

**AC代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define debug(x) cout<<"###"<<x<<"###"<<endl;
//int a[100005];
int a[15];
int ans[1000005];
int siz=0;
//vector<int>ans;
int main(){
	int t;
	int n;
	
	scanf("%d",&t);
	while(t--){
		siz=0;
		scanf("%d",&n);
		memset(a,0,sizeof(a));
		//ans.clear();
		
		for(int i=0;i<n;i++){
			int x;
			scanf("%d",&x);
			a[x]++;
		}
		//sort(a.begin(),a.begin()+n);
		int cnt_zero = a[0];
		int cnt=1;
		while(a[cnt]==0){
			cnt++;
		}
		int x=cnt;
		a[cnt]--;
		while(a[cnt]==0){
			cnt++;
		}
//		debug(cnt);
		ans[siz++]=cnt;
		//ans.push_back(cnt);
		a[cnt]--;
		for(int i=0;i<cnt_zero;i++){
			ans[siz++]=0;
			//ans.push_back(0);
		}
		for(int i=1;i<=9;i++){
			while(a[i]>0){
				ans[siz++]=i;
				//ans.push_back(i);
				a[i]--;
			}
		}
//		for(int i=0;i<siz;i++){
//				printf("%d",ans[i]);
//		}
		
		for(int i=0;i<siz;i++){
			ans[i]*=x;
		}
		for(int i=siz-1;i>0;i--){
			if(ans[i]>=10){
				ans[i-1]+=(ans[i]/10);
				ans[i]%=10;
			}
		}
		for(int i=0;i<siz;i++){
			printf("%d",ans[i]);
		}
		printf("\n");
	}
	return 0;
}
```

