### [A. Groundhog and 2-Power Representation](https://ac.nowcoder.com/acm/contest/5674/A)


### **题意**  
给出2的次幂组合表达式，输出结果
### **思路**  
模拟 

将`(`换成`**(`



### **代码** 
```
a=input()
b=len(a)
flag = 0
ans = 0
cnt = 0
v=[]
for i in range(0, b):
    if a[i] == '2':
        v.append(2)
    elif a[i] == '0':
        v.append(0)
    elif a[i] == '(':
        v.append(-1)
    elif a[i] == ')':
        sum1 = 0
        while v[-1] != -1:
            tmp = v[-1]
            sum1 += tmp
            v.pop()
        v.pop()
        v.pop()
        v.append(2**sum1)
for i in v:
    ans += i
print(ans)

```

### [F. Groundhog Looking Dowdy](https://ac.nowcoder.com/acm/contest/5674/F)


### **题意**  

从n天中选择m天，使m天内所穿衣服的最大权值与最小权值的差最小

### **思路** 

尺取法（~~比赛时用最小值排序水过去了)~~

根据衣服的权值先排序，不断更新区间，每当达到m天时，更新最小差值即可。
### **代码** 
```
#pragma warning(disable:4996)
#include<algorithm>
#include <iostream>
#include<string.h>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
struct cloth {
	int index;
	int value;
}c[2000005];
int vis[2000005];
bool cmp(cloth a, cloth b) {
	return a.value < b.value;
}
int main() {
	int m, n,t,x=0;
	scanf("%d%d", &n, &m);
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		scanf("%d", &t);
		while (t--) {
			x++;
			c[x].index = i;
			scanf("%d", &c[x].value);
			
		}
	}
	sort(c + 1, c + x + 1, cmp);
	/*for (int i = 1; i <= x; i++)
		cout << c[i].value << endl;*/
	int l = 1,sum = 0,count=0,ans=0x3f3f3f3f;
	for (int i = 1; i <= x; i++) {
		if (!vis[c[i].index])sum++;
		vis[c[i].index]++;
		while (sum > m) {
			vis[c[i].index]--;
			l++;
			sum--;
		}
		if (sum == m)
			ans = min(ans, c[i].value - c[l].value);
	}
	printf("%d\n", ans);
	return 0;
}



```


### [I. The Crime-solving Plan of Groundhog](https://ac.nowcoder.com/acm/contest/5674/I)


### **题意**  
给出n个数，由这个数组成两个数，使乘积最小
### **思路**  

从小到大排序，选最小非零的数与剩下的数乘积最小。（剩下的数为最小非零+多个0+其他）


### **代码** 
```
#pragma warning (disable:4996)
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <cstdio>
#include <queue>
#include <stack>
#include <cmath>
#include <map>
#define inf 0X7f7f7f7f
#define MS_I(x) memset(x,-inf,sizeof(x))
#define MS(x) memset(x,0,sizeof(x))
#define MS_1(x) memset(x,-1,sizeof(x))
#define MSI(x) memset(x,inf,sizeof(x))
#define random(a,b) ((long long)rand()%(b-a+1)+a)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 1e5 + 20;
//const int maxm = 2e5 + 20;
const int mod = 1e9 + 7;
vector <int> vm;
vector <int> vg;
int ar[maxn];
int br[maxn];

int main()
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		int n;
		scanf("%d", &n);
		int cnt = 0;
		int n0 = 0;
		while (n--)
		{
			int tmp;
			scanf("%d", &tmp);
			if (tmp == 0)
				n0++;
			else
				ar[cnt++] = tmp;
		}
		sort(ar, ar + cnt);
		int k = ar[0];
		ar[0] = 0;
		if (k == 1)
		{
			for (int i = 1; i < cnt; i++)
			{
				printf("%d", ar[i]);
				if (i == 1)
				{
					while (n0--)
					{
						printf("0");
					}
				}
			}
			printf("\n");
			continue;
		}
		else
		{
			if (n0 != 0)
			{
				int f = k * ar[1];
				ar[1] = 0;
				int tmp = 0;
				for (int i = cnt - 1; i > 1; i--)
				{
					ar[i] = ar[i] * k + tmp;
					tmp = ar[i] / 10;
					ar[i] %= 10;
				}
				ar[1] = tmp;
				if (tmp != 0)
				{
					n0--;
				}
				int flag = 0;
				printf("%d", f);
				while (n0--)
				{
					printf("0");
				}
				for (int i = 1; i < cnt; i++)
				{
					if (!flag && ar[i] == 0)
						continue;
					if (!flag && ar[i] != 0)
						flag = 1;
					printf("%d", ar[i]);
				}
				printf("\n");
				continue;
			}
			else
			{
				int tmp = 0;
				for (int i = cnt - 1; i > 0; i--)
				{
					ar[i] = ar[i] * k + tmp;
					tmp = ar[i] / 10; 
					ar[i] %= 10;
				}
				ar[0] = tmp;
				int flag = 0;
				for (int i = 0; i < cnt; i++)
				{
					if (!flag && ar[i] == 0)
						continue;
					if (!flag && ar[i] != 0)
						flag = 1;
					printf("%d", ar[i]);
				}
				printf("\n");
				continue;
			}
		}
	}
}
```