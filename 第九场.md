#### 2020牛客暑假多校训练营第九场总结
##### 题目解析
###### A题题意
给你一个用2的多少多少幂次加起来的字符串，其中1用2（1）表示，2就用2表示，问你这个字符串表示的数是多少？
解题思路：不会python敲半天系列~直接把(替换成**(然后eval一下就是答案（是时候学一下python了）
```python
s=input()
s=s.replace('(', '**(')
print(eval(s))
```
###### I题题意
给你n个数，范围[0,9]，保证这n个数里至少有两个数的值非0，现在问你用这n个数拼成两个正整数，然后让这两个正整数相乘，能得到的最小乘积是多少。
解题思路：经过推证，结果一定是(n-1）个数和1个数相乘得到的数最小，其中1个数为除0外最小的数，剩余的n-1个数构造最小的数：首先把最小数放在最前面，然后在第一个数之后全都放0，再把剩下的数从小到大放在后面。
```C++
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+100;
int t,n,a[maxn];
int main() {
    cin>>tc;
    while(t--){
        cin>>n;
        int cnt0=0;
        vector<int> res;
        for(int i=1; i<=n; ++i){
            cin>>a[i];
            if(a[i]==0) ++cnt0;
            else res.emplace_back(a[i]);
        }
        sort(res.begin(), res.end());
        int b=res[0];
        string a="";
        a+=char((int)'0'+res[1]);
        for(int i=0; i<cnt0; ++i) a+='0';
        for(int i=2; i<int(res.size()); ++i) a+=char(int('0')+res[i]);
        string ans="";
        int add=0;
        for(int i=int(a.size())-1; i>=0; --i){
            int num=int(a[i]-'0');
            int mul=num*b;
            mul+=add;
            add=mul/10;
            ans+=char(int('0')+mul%10);
        }
        if(add>0) ans+=char(int('0')+add);
        reverse(ans.begin(), ans.end());
        cout<<ans<<'\n';
    }
    return 0;
}
```

###### F题解题题意
输入n和m，表示n天中要选m天穿衣服，下面输入n行，每行一个数为num，接下来num个数分别表示第i天穿的衣服的魅力值。选m天里每天穿一件衣服，求最小的（max魅力值-min魅力值）是多少。
解题思路：运用尺取法再用sort排序即可转化为尺取问题。
```C++
#include <bits/stdc++.h>
using namespace std;
const int maxn=2*(int)1e6+100;
int n,m,cnt[maxn];
struct node{
    int x,id;
}nd[maxn];
bool cmp(node a, node b){
    return a.x<b.x;
}
int main() {
    cin>>n>>m;
    int tot=0;
    for(int i=1; i<=n; ++i){
        int num,temp;
        cin>>num;
        for(int j=0; j<num; ++j){
            cin>>temp;
            nd[++tot].x=temp;
            nd[tot].id=i;
        }
    }
    sort(nd+1, nd+1+tot, cmp);
    int ans=INT_MAX;
    int l=1,r=1,sum=0;
    memset(cnt,0,sizeof(cnt));
    for(;;){
        while(r<=tot && sum<m){ 
            if(cnt[nd[r].id]==0){
                ++sum;
            }
            ++cnt[nd[r++].id];
        }
        if(sum<m) break;
        ans=min(ans, nd[r-1].x-nd[l].x);
        --cnt[nd[l].id];
        if(cnt[nd[l++].id]
       --sum;
        }
    }
    cout<<ans<<'\n';
    return 0;
}
```
###### E题解题思路：
令
xi=p1^a1∗p2^a2∗p3^a3∗......pn^an;
yj=q1^b1∗q2^b2∗q3^b3∗......qm^bm;
可发现，xi和yj的最大公因数一开始很快的增长，后来不变。假设i < j,因为当x,y中指数较小的一个和另一个数两两匹配完之后就只剩下指数较大的那个数了，也就是yj−i。然后发现，前i−1个gcd的值依次递增，所以可以用等差数列来求，后j−i+1个y和x的最大公因数相同，可以直接计算，如果最后x>1，说明x和y可能还有质因数，再做一遍即可。
时间复杂度O(N)。
```C++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=998244353;
ll a,b,c,d,x,y,z,ans=1,n,u,v,md=mod-1;
ll ksm(ll a,ll b){
	ll ret=1;
	while(b){
		if(b&1)ret=ret*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ret;
}
ll get(ll x,ll y){
	ll k=0,p;
	for(int i=1;i<=x;i++){
		p=u*i/v;
		p=min(p,y);
		k=(k+(p+1ll)*p/2%md*v)%md;
		k=(k+1ll*i*(y-p)%md*u)%md;
	}
	return k;
}
int main(){
	scanf("%lld%lld%lld%lld%lld%lld",&a,&b,&c,&d,&x,&y);
	n=max(x,y);
	for(int i=2;i*i<=n;i++){
		while(x%i==0) u++,x/=i;
		while(y%i==0) v++,y/=i;
		if(u&&v){
			z=(2ll*md+get(b,d)+get(a-1,c-1)-get(a-1,d)-get(b,c-1))%md;
			ans=1ll*ans*ksm(i,z)%mod;
		}
		u=v=0;
	}
	if(x^0&&x==y){
		u=v=1;
		z=(2ll*md+get(b,d)+get(a-1,c-1)-get(a-1,d)-get(b,c-1))%md;
		ans=1ll*ans*ksm(x,z)%mod;
	}
	printf("%lld",ans);
}

```
