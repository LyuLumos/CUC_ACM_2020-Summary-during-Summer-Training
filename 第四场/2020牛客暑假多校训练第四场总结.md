# 2020牛客暑假多校训练第四场总结

## 关于比赛：

这次的题感觉比第三场的题目整体难度要高（~~主要是做出来的就少~~）。签到题设置了一道找规律的题目，难度还可以。但是第二道题B的卡时卡的很迷惑，也不知道是后台出了什么bug还是我们头太铁.......

整体分析这次比赛，队伍的状态一般。就签到题而言，原本就是一道很简单的思维题，但是团队一开始对这个题目的定位就出现了偏差，导致队伍一直在往复杂的方向走。而对于B题首先我们的思路一开始就没有统一，到底是质因子的个数还是质因子的种类数这一点上在最后一直没有达成共识。

对自己而言，这次比赛的状态奇差，可能是因为牵扯的数学知识比较多，自己的薄弱环节又恰恰是这方面。以后需要对数学类题目加以练习总结，对相关的数学知识还需要自己多去学习。

对于团队而言，这一次的交流配合不够默契，有些题目没有办法快速达成共识，还需要时间加强团体训练，增强团队默契度和节奏感。（~~也许我们缺一次饭局~~）

## 题解：

### F.Finding the Order

**题目描述：**

![](C:\Users\hp\Desktop\329337_1594891605277_AE8E2FF51CF6CE451D3702D26FA94C98.png)

如图所示，现在告诉你AC,AD,BC,BD的距离，需要你判断D和C的位置以此来判断是AB||CD还是AB||DC

**思路：**

一开始想枚举AB的长度，后来发现AB的值有可能是浮点数,根本没法做.....

其实这个题的思路就是找到一条最长的边，这条边就一定是我们说的对角线，那么我们就只需要判断和它相连的是A还是B就可以了。

**AC代码：**

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
    int t;
    cin >> t;
    while(t--){
        int a,b,c,d;//AC,AD,BC,BD
        cin >> a >> b >> c >> d;
        int maxm = max(max(a,b),max(c,d));
        if(maxm == a){
            cout << "AB//DC" << endl;
        }
        else if(maxm == b){
            cout << "AB//CD" << endl;
        }
        else if(maxm == c){
            cout << "AB//CD" << endl;
        }
        else if(maxm == d){
            cout << "AB//DC" << endl;
        }
    }
    return 0;
}
```

### B.Basic Gcd Problem

**题目描述：**

![](C:\Users\hp\Desktop\20200721222020.png)

上面给出了一个函数``F(x)``，现在需要你计算对任意的n,c,F(x)的值。

 **思路**

首先这个题如果强行递归肯定是不行的，会卡时间。

那么就要找一下规律，我们发现对于任意的一组n,c。他最后对应的得到的F(x)的值总是C的幂次方，幂次方的值恰好等于n的质因数的个数（**注意：这里一直没有达成共识的是，到底是质因数的个数还是质因数的种数！**）

所以这个题就比较明确了，用试除法试出质因子数，然后用一下快速幂得到结果就可以。

**AC代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const double eps=1e-8;
const int maxn = 2e5+5;
const ll mod = 1e9+7;
const int inf = 0x3f3f3f3f;
int t;
int n,c;
ll qpow(ll a,ll b,ll mod)
{
    ll ans=1%mod;
    for(;b;b>>=1){
        if(b&1) ans=ans*a%mod; 
        a=a*a%mod;
    } 
    ans=(ans%mod+mod)%mod;
    return ans;
}
ll solve(int n) //试除法得质因字数
{
    ll cnt = 0;
    for(int i=2;i<=(int)sqrt(n);++i)
    {
        if(n%i==0)
        {
            while(n%i==0) n/=i,++cnt;
        }
    }
    if(n>1) ++cnt;
    return cnt;
}
ll p[1000005];
int main()
{
    for(int i=1;i<=1000000;++i)
    {
        p[i] = solve(i);
    } //提前预处理一下，减少时间复杂度
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&c);
        if(n==1) puts("1");
        else
        {
            ll b = p[n];
            printf("%lld\n",qpow(c,b,mod));
        }
    }
    return 0;
}
```
